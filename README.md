# Clean Architecture: Repositório dos artigos do meu blog. 

- Site: https://lucaswesley.dev


## Artigos

[X] - IA MCP A TEORIA:
[X] - IA Prompt Engineering:
[X] - DDD

[-] - Hexagonal Architecture e Clean Architecture
[ ] - Design Patterns

[] - NODE JS: É Single Thread? Entendendo o Event Loop:


## GOLANG

### FUNDAMENTOS

[X] - Golang: Motivações, Criadores e Vantagens (Parte 1)
[X] - Golang: GOPATH e Go Modules (Parte 2)
[X] - Golang: Packages (Parte 3)
[X] - Golang: Variáveis (Parte 4)
[X] - Golang: Package fmt (Parte 5)
[X] - Golang: Arrays e Slices (Parte 6)
[X] - Golang: Maps (Parte 7)
[X] - Golang: Funções (Parte 8)
[X] - Golang: Structs (Parte 9)
[X] - Golang: Ponteiros (Parte 10)
[X] - Golang: Interfaces Vazias (Parte 11)
[X] - Golang: Type Assertion (Parte 12)
[X] - Golang: Generics (Parte 13)
[X] - Golang: Pacotes e módulos (Parte 14)
[X] - Golang: For e Condicionais (Parte 15)
[X] - Golang: Compilando projeto (Parte 16)
[X] - Golang: Manipulação de arquivos (Parte 17)
[X] - Golang: Defer (Parte 18)


Escrevi alguns artigos sobre Golang, quero que você continue a escrever sobre o assunto.
A sequência de artigos está no arquivo README.md na seção GOLANG -> FUNDAMENTOS.
Para escrever os artigos, você deve seguir o seguinte padrão:
- O artigo deve ser escrito em markdown e seguir o padrão dos artigos já escritos da pasta artigos/golang.
- O estilo de escrita deve ser parecido com o dos artigos já escritos da pasta artigos/golang.
- Para cada assunto, você deve fazer uma pesquisa profunda antes de escrever o artigo.
E depois de escrever o artigo, você deve atualizar o arquivo README.md.










## Arquitetura e Design de Software

[] - Arquitetura e Design de Software: Quais as diferenças entre esses dois conceitos? (Parte 1)




## DDD

[X] - DDD: Introdução aos conceitos fundamentais
[X] - DDD: Ubiquitous Language - A linguagem comum do domínio
[X] - DDD: Bounded Contexts - Delimitando contextos
[X] - DDD: Value Objects e Entities
[X] - DDD: Agregados e Aggregate Roots
[X] - DDD: Domain Services vs Application Services
[X] - DDD: Repositories - Abstraindo o acesso aos dados
[X] - DDD: Domain Events - Comunicação entre contextos
[X] - DDD: Context Mapping
[X] - DDD: Anti-Corruption Layer
[X] - DDD: Specification Pattern
[X] - DDD: CQRS e Event Sourcing
[X] - DDD: Hexagonal Architecture e Clean Architecture

## Clean Architecture

### 1. Fundamentos da Clean Architecture
[X] - Clean Architecture: O que é e por que usar (Parte 1)](./artigos/clean-architecture/1.clean-architecture-o-que-e-e-por-que-usar.md)
[X] - Os Princípios Fundamentais de Uncle Bob (Parte 2)](./artigos/clean-architecture/2.clean-architecture-principios-fundamentais-uncle-bob.md)
[X] - A Regra de Dependência: O coração da arquitetura (Parte 3)](./artigos/clean-architecture/3.clean-architecture-regra-de-dependencia.md)
[X] - As 4 Camadas da Clean Architecture: Visão Geral (Parte 4)](./artigos/clean-architecture/4.clean-architecture-4-camadas-visao-geral.md)
[X] - Independence of Frameworks, UI e Database (Parte 5)](./artigos/clean-architecture/5.clean-architecture-independence-frameworks-ui-database.md)

### 2. O Núcleo: Domínio e Aplicação
[X] - Entities: O núcleo do negócio (Parte 6)](./artigos/clean-architecture/6.clean-architecture-entities-nucleo-negocio.md)
[X] - Value Objects: Encapsulando regras de domínio (Parte 7)](./artigos/clean-architecture/7.clean-architecture-value-objects-encapsulando-regras-dominio.md)
[X] - Aggregates: Organizando entidades relacionadas (Parte 8)](./artigos/clean-architecture/8.clean-architecture-aggregates-organizando-entidades.md)
[X] - Domain Services: Quando usar e como implementar (Parte 9)](./artigos/clean-architecture/9.clean-architecture-domain-services-quando-usar.md)
[X] - Use Cases: Regras de negócio da aplicação (Parte 10)](./artigos/clean-architecture/10.clean-architecture-use-cases-regras-negocio-aplicacao.md)
[X] - Application Services: Orquestrando o domínio (Parte 11)](./artigos/clean-architecture/11.clean-architecture-application-services-orquestrando-dominio.md)

### 3. Princípios e Padrões Essenciais
[X] - Dependency Inversion: Teoria e implementação (Parte 12)](./artigos/clean-architecture/12.clean-architecture-dependency-inversion-teoria-implementacao.md)
[X] - Separation of Concerns na prática (Parte 13)](./artigos/clean-architecture/13.clean-architecture-separation-of-concerns-na-pratica.md)
[X] - Repository Pattern em Clean Architecture (Parte 14)](./artigos/clean-architecture/14.clean-architecture-repository-pattern.md)
[X] - Error Handling e Exception Management (Parte 15)](./artigos/clean-architecture/15.clean-architecture-error-handling-exception-management.md)
[X] - Validation Strategies nas diferentes camadas (Parte 16)](./artigos/clean-architecture/16.clean-architecture-validation-strategies.md)
[X] - O Princípio da Estabilidade (Parte 17)](./artigos/clean-architecture/17.clean-architecture-principio-estabilidade.md)

### 4. Interface e Infraestrutura
[X] - Interface Adapters: Controllers, Presenters e Gateways (Parte 18)](./artigos/clean-architecture/18.clean-architecture-interface-adapters.md)
[X] - Frameworks e Drivers: A camada mais externa (Parte 19)](./artigos/clean-architecture/19.clean-architecture-frameworks-drivers.md)
[X] - Dependency Injection na prática (Parte 20)](./artigos/clean-architecture/20.clean-architecture-dependency-injection.md)
[X] - Data Mappers: Transformando entre camadas (Parte 21)](./artigos/clean-architecture/21.clean-architecture-data-mappers.md)
[X] - Configuração e Bootstrap da aplicação (Parte 22)](./artigos/clean-architecture/22.clean-architecture-configuracao-bootstrap.md)

### 5. Implementação com Ports and Adapters
[X] - Ports and Adapters: Implementando Clean Architecture (Parte 23)](./artigos/clean-architecture/23.clean-architecture-ports-and-adapters.md)
[X] - Primary vs Secondary Ports na prática (Parte 24)](./artigos/clean-architecture/24.clean-architecture-primary-secondary-ports.md)
[X] - Implementando Adapters eficazes (Parte 25)](./artigos/clean-architecture/25.clean-architecture-implementing-adapters.md)
[X] - Testing com Ports and Adapters (Parte 26)](./artigos/clean-architecture/26.clean-architecture-testing-ports-adapters.md)
[X] - Hexagonal Architecture: Uma implementação de Clean Architecture (Parte 27)](./artigos/clean-architecture/27.clean-architecture-hexagonal-architecture.md)

### 6. Event-Driven e CQRS
[ ] - Domain Events: Comunicação entre contextos
[ ] - Event-Driven Architecture com Clean Architecture
[ ] - CQRS: Separando Commands e Queries
[ ] - Event Sourcing em Clean Architecture
[ ] - Sagas e Orchestration em arquiteturas distribuídas

### 7. Testing: O Grande Benefício
[ ] - Testabilidade: Por que Clean Architecture facilita testes
[ ] - Testing in Isolation: Sem dependências externas
[ ] - Testes Unitários para Entities e Use Cases
[ ] - Testes de Integração com Ports and Adapters
[ ] - Architecture Testing: Validando regras estruturais
[ ] - Test-Driven Development com Clean Architecture

### 8. Estrutura e Organização
[ ] - Estrutura de Pastas e Organização do Código
[ ] - Feature Folders vs Technical Layers
[ ] - Package by Component vs Package by Layer
[ ] - Naming Conventions e Code Style
[ ] - Documentação de Arquitetura

### 9. Casos de Uso e Implementações Práticas
[ ] - Clean Architecture em APIs REST
[ ] - Clean Architecture em Microserviços
[ ] - Clean Architecture para E-commerce
[ ] - Clean Architecture em Sistemas Financeiros
[ ] - Clean Architecture com GraphQL
[ ] - Legacy System Migration para Clean Architecture

### 10. Comparações e Contexto
[ ] - Clean Architecture vs Layered Architecture
[ ] - Clean Architecture vs Hexagonal Architecture
[ ] - Clean Architecture vs Onion Architecture
[ ] - DDD e Clean Architecture: Como se complementam
[ ] - Quando usar Clean Architecture vs outras abordagens

### 11. Aspectos Avançados
[ ] - Performance e Otimizações em Clean Architecture
[ ] - Observabilidade e Monitoring
[ ] - Multi-tenancy em Clean Architecture
[ ] - Caching Strategies
[ ] - Background Jobs e Async Processing
[ ] - API Versioning e Backward Compatibility

### 12. Pitfalls e Anti-padrões
[ ] - Quando NÃO usar Clean Architecture
[ ] - Over-engineering: Evitando complexidade desnecessária
[ ] - Anemic Domain Model: Identificando e corrigindo
[ ] - Vazamento de abstrações entre camadas
[ ] - Erros comuns na implementação
[ ] - Code Smells específicos da Clean Architecture

### 13. Ferramentas e Ecossistema
[ ] - Frameworks que facilitam Clean Architecture em PHP
[ ] - Bibliotecas de Dependency Injection
[ ] - Architecture Testing: PHPArch e ferramentas
[ ] - Static Analysis para validação arquitetural
[ ] - Code Review em projetos Clean Architecture
[ ] - DevOps e CI/CD para arquiteturas limpas

## Design Patterns

### Fundamentos e Introdução
[X] - Design Patterns: O que são, importância, categorias, padrões populares e quando usar
[-] - Design Patterns: Como implementar exatamente - Boas práticas e armadilhas
[ ] - História dos Design Patterns: Do Gang of Four aos padrões modernos
[ ] - Design Patterns vs Princípios de Design: Diferenças e complementaridade
[ ] - Quando NÃO usar Design Patterns: Evitando over-engineering
[ ] - Design Patterns em diferentes paradigmas: OOP, Funcional e Procedural

### Princípios SOLID
[-] - Single Responsibility Principle: Uma razão para mudar
[-] - Open/Closed Principle: Aberto para extensão, fechado para modificação
[-] - Liskov Substitution Principle: Substituibilidade e herança correta
[-] - Interface Segregation Principle: Interfaces específicas vs genéricas
[-] - Dependency Inversion Principle: Abstrações vs concretizações
[-] - DIP vs DI: Diferenças entre princípio e padrão
[ ] - SOLID na prática: Casos reais e refatoração de código
[ ] - SOLID em PHP: Implementação e exemplos práticos

### Padrões Criacionais (GoF)
[-] - Singleton: Instância única e acesso global
[ ] - Factory Method: Criação de objetos através de métodos
[ ] - Abstract Factory: Famílias de objetos relacionados
[ ] - Builder: Construção step-by-step de objetos complexos
[ ] - Prototype: Clonagem de objetos existentes
[ ] - Factory vs Factory Method vs Abstract Factory: Diferenças práticas
[ ] - Object Pool: Reutilização de objetos caros

### Padrões Estruturais (GoF)
[ ] - Adapter: Compatibilidade entre interfaces incompatíveis
[ ] - Bridge: Separação entre abstração e implementação
[ ] - Composite: Estruturas de árvore com objetos simples e compostos
[ ] - Decorator: Adição de comportamentos sem alterar estrutura
[ ] - Facade: Simplificação de interfaces complexas
[-] - Proxy: Controle de acesso e lazy loading
[ ] - Flyweight: Compartilhamento eficiente de objetos similares

### Padrões Comportamentais (GoF)
[ ] - Chain of Responsibility: Cadeia de processamento de requisições
[ ] - Command: Encapsulamento de comandos como objetos
[ ] - Interpreter: Implementação de linguagens específicas
[ ] - Iterator: Acesso sequencial a elementos de coleções
[ ] - Mediator: Comunicação entre objetos através de mediador
[ ] - Memento: Captura e restauração de estados de objetos
[ ] - Observer: Notificação automática de mudanças de estado
[ ] - State: Alteração de comportamento baseada no estado interno
[ ] - Strategy: Família de algoritmos intercambiáveis
[ ] - Template Method: Esqueleto de algoritmo com passos variáveis
[ ] - Visitor: Operações em estruturas de objetos sem modificá-las

### Padrões Arquiteturais e Empresariais
[ ] - Model-View-Controller (MVC): Separação de responsabilidades em UI
[ ] - Model-View-Presenter (MVP): Evolução do MVC
[ ] - Model-View-ViewModel (MVVM): Binding e observabilidade
[ ] - Repository: Abstração da camada de dados
[-] - Gateway: Interface para sistemas externos
[-] - Registry: Registro global de objetos e serviços
[ ] - Unit of Work: Transações business e controle de mudanças
[ ] - Data Mapper: Separação entre domain model e database
[ ] - Active Record: Objetos que encapsulam dados e comportamento
[ ] - Table Data Gateway: Acesso a tabelas através de gateways

### Padrões de Integração e Comunicação
[ ] - Publish-Subscribe: Comunicação assíncrona entre componentes
[ ] - Request-Response: Comunicação síncrona cliente-servidor
[ ] - Message Queue: Filas para processamento assíncrono
[ ] - API Gateway: Ponto único de entrada para APIs
[ ] - Service Locator: Localização de serviços de forma dinâmica
[ ] - Dependency Injection: Inversão de controle na prática
[ ] - Event Sourcing: Armazenamento de eventos ao invés de estado
[ ] - CQRS: Separação de comandos e consultas
[ ] - Transactional Outbox: Garantia de consistência em eventos
[ ] - Two-Phase Commit vs Saga Pattern: Comparação de abordagens distribuídas

### Padrões Modernos e Microserviços
[ ] - Circuit Breaker: Proteção contra falhas em cascata
[ ] - Bulkhead: Isolamento de recursos e falhas
[ ] - Retry Pattern: Tentativas automáticas em caso de falha
[ ] - Timeout Pattern: Controle de tempo limite em operações
[ ] - Saga Pattern: Transações distribuídas em microserviços (Choreography vs Orchestration)
[ ] - Saga Pattern: Gestão de falhas e compensação em operações distribuídas
[ ] - Saga Pattern: Implementação prática com eventos e comandos
[ ] - Backend for Frontend (BFF): APIs específicas por cliente
[ ] - Strangler Fig: Migração gradual de sistemas legados
[ ] - Ambassador: Proxy para serviços externos

### Padrões de Concorrência e Performance
[ ] - Producer-Consumer: Produção e consumo assíncrono
[ ] - Reader-Writer Lock: Controle de acesso concorrente
[ ] - Thread Pool: Reutilização de threads
[ ] - Future/Promise: Processamento assíncrono
[ ] - Actor Model: Concorrência baseada em atores
[ ] - MapReduce: Processamento distribuído de dados
[ ] - Cache Patterns: Estratégias de cache (Cache-Aside, Write-Through, etc.)
[ ] - Lazy Loading: Carregamento sob demanda

### Padrões de Segurança
[ ] - Authentication vs Authorization: Diferenças e implementação
[ ] - Role-Based Access Control (RBAC): Controle baseado em papéis
[ ] - Token-Based Authentication: JWT e OAuth
[ ] - Secure Proxy: Proxy com validação de segurança
[ ] - Input Validation: Validação segura de dados de entrada
[ ] - Audit Trail: Rastreamento de ações para auditoria

### Anti-Padrões e Armadilhas Comuns
[ ] - God Object: Classes que fazem tudo
[ ] - Spaghetti Code: Código sem estrutura clara
[ ] - Copy-Paste Programming: Duplicação desnecessária
[ ] - Golden Hammer: Usar a mesma solução para tudo
[ ] - Premature Optimization: Otimização precoce
[ ] - Feature Envy: Classes que usam demais outras classes
[ ] - Anemic Domain Model: Modelo de domínio sem comportamento
[ ] - Big Ball of Mud: Arquitetura sem estrutura

### Implementação Prática
[ ] - Design Patterns em PHP: Implementação e boas práticas
[ ] - Estrutura de Código e Organização de Patterns
[ ] - Autoloading e Namespaces com Design Patterns

### Ferramentas e Ecossistema
[ ] - IDEs e Design Patterns: Templates e geradores
[ ] - Code Analysis: Detecção automática de patterns
[ ] - Refactoring Tools: Transformação para patterns
[ ] - Documentation: Como documentar o uso de patterns
[ ] - Code Review: Avaliação de patterns em peer review
[ ] - Testing Patterns: Patterns específicos para testes

### Estudos de Caso e Aplicações Reais
[ ] - Design Patterns em E-commerce: Casos práticos
[ ] - Design Patterns em Sistemas Financeiros: Segurança e precisão
[ ] - Design Patterns em Games: Performance e flexibilidade
[ ] - Design Patterns em APIs REST: Estruturação e versionamento
[ ] - Design Patterns em Frontend: React, Vue, Angular patterns
[ ] - Design Patterns em DevOps: Infrastructure as Code patterns
[ ] - Design Patterns em Data Engineering: ETL e pipelines

### Tópicos Avançados
[ ] - Pattern Languages: Linguagens de padrões
[ ] - Domain-Specific Patterns: Padrões específicos por domínio
[ ] - Evolutionary Design: Evolução de código com patterns
[ ] - Pattern Mining: Descoberta automática de patterns
[ ] - Metrics and Patterns: Métricas para avaliar qualidade
[ ] - Performance Impact: Overhead dos patterns
[ ] - Testing Design Patterns: Como testar código que usa patterns
