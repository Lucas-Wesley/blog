---
title: "DDD: Domain Services vs Application Services - Organizando a lógica de negócio (Parte 6)"
date: "2025-05-15 14:00"
status: "published"
description: "Entenda as diferenças fundamentais entre Domain Services e Application Services no DDD, quando usar cada um e como organizá-los para criar uma arquitetura clara e testável."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-domain-services-vs-application-services"
tags: ["DDD", "Domain Services", "Application Services", "Arquitetura", "Orquestração", "CQRS"]
---

Este é o sexto artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos os conceitos fundamentais do DDD, Value Objects, Entities e Agregados. Agora chegou o momento de entender uma distinção crucial na arquitetura DDD: **Domain Services vs Application Services**.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

## O que são Services no DDD?

No DDD, **Services** (Serviços) são classes stateless que encapsulam operações que não pertencem naturalmente a nenhuma Entity ou Value Object específico. Eles representam conceitos do domínio que são expressos como verbos ou atividades, em vez de substantivos.

Como Eric Evans define:

> "Às vezes, fica claro que um conceito importante do domínio não é algo natural para modelar como um objeto. O conceito que você está tentando expressar é mais uma atividade ou ação, não uma coisa."

### Por que Precisamos de Services?

Nem toda lógica de negócio pertence a Entities ou Value Objects. Quando encontramos operações que:

1. **Envolvem múltiplos objetos de domínio**
2. **Não têm uma "casa natural" em nenhuma Entity específica**
3. **Representam conceitos importantes do domínio**
4. **Precisam ser testáveis independentemente**

É neste momento que Services entram em cena para evitar que Entities fiquem sobrecarregadas ou que lógica importante fique espalhada.

## A Diferença Fundamental

A diferença principal entre Domain Services e Application Services pode ser resumida em uma pergunta simples:

**"Este código toma decisões de negócio?"**

- **Se SIM** → Domain Service
- **Se NÃO** → Application Service

### Domain Services: A Lógica Pura do Domínio

**Domain Services** contêm lógica de negócio pura que é parte essencial do domínio. Eles lidam com operações que envolvem conceitos de domínio mas não pertencem a nenhuma Entity específica.

#### Características dos Domain Services:

1. **Contêm lógica de domínio** - Tomam decisões de negócio.
2. **São stateless** - Não mantêm estado entre chamadas.
3. **Trabalham com objetos de domínio** - Entities, Value Objects, outros Domain Services.
4. **Podem ser "puros" ou "impuros"** - Dependendo se acessam infraestrutura.

#### Exemplo: Calculadora de Desconto

```php
class CalculadoraDesconto
{
    public function calcularDesconto(Cliente $cliente, Produto $produto): Desconto
    {
        // Lógica de domínio: regras de desconto baseadas no cliente
        $percentualBase = match($cliente->getTipo()) {
            TipoCliente::BRONZE => 0.05,
            TipoCliente::PRATA => 0.10,
            TipoCliente::OURO => 0.15,
            TipoCliente::DIAMANTE => 0.20
        };
        
        // Bônus por tempo de relacionamento
        $bonusTempo = $cliente->getTempoRelacionamento() >= 5 ? 0.05 : 0.0;
        
        // Bônus por categoria do produto
        $bonusCategoria = match($produto->getCategoria()) {
            CategoriaProduto::ELETRONICOS => 0.03,
            CategoriaProduto::LIVROS => 0.15,
            default => 0.0
        };
        
        $percentualFinal = min($percentualBase + $bonusTempo + $bonusCategoria, 0.5);
        
        return new Desconto($percentualFinal, "Desconto aplicado conforme perfil do cliente");
    }
}
```

### Application Services: Orquestração e Coordenação

**Application Services** são responsáveis por orquestrar operações e coordenar o fluxo de trabalho das operações de negócio. Eles atuam como uma "camada de fachada" que esconde a complexidade do domínio das camadas externas.

#### Características dos Application Services:

1. **Não contêm lógica de domínio** - Apenas orquestram.
2. **Coordenam operações** - Chamam Domain Services, Aggregates, Repositories.
3. **Gerenciam transações** - Definem fronteiras transacionais.
4. **Interface com o mundo externo** - UI, APIs, mensageria.
5. **Retornam DTOs** - Não expõem objetos de domínio diretamente.

#### Exemplo: Application Service para Processamento de Pedido

```php
// Command para criar pedido
final readonly class CriarPedidoCommand
{
    public function __construct(
        public string $clienteId,
        public array $itens,
        public string $enderecoEntregaId,
        public string $metodoPagamento
    ) {}
}

// Application Service
class ProcessarPedidoApplicationService
{
    public function __construct(
        private readonly ClienteRepository $clienteRepository,
        private readonly ProdutoRepository $produtoRepository,
        private readonly PedidoRepository $pedidoRepository,
        private readonly CalculadoraDesconto $calculadoraDesconto,
        private readonly NotificacaoService $notificacaoService
    ) {}
    
    public function criarPedido(CriarPedidoCommand $command): CriarPedidoResult
    {
        // 1. Buscar e validar dados necessários
        $cliente = $this->clienteRepository->buscarPorId(new ClienteId($command->clienteId));
        $produtos = $this->buscarProdutos($command->itens);
        
        // 2. Criar o agregado Pedido
        $pedido = new Pedido(PedidoId::gerar(), $cliente->getId());
        
        // 3. Adicionar itens ao pedido
        foreach ($command->itens as $itemData) {
            $produto = $produtos[$itemData['produtoId']];
            $pedido->adicionarItem($produto->getId(), $itemData['quantidade'], $produto->getPreco());
        }
        
        // 4. Aplicar desconto usando Domain Service
        $desconto = $this->calculadoraDesconto->calcularDesconto($cliente, $pedido);
        $pedido->aplicarDesconto($desconto);
        
        // 5. Confirmar pedido e reduzir estoque
        $pedido->confirmar();
        foreach ($produtos as $produto) {
            $produto->reduzirEstoque($itemData['quantidade']);
            $this->produtoRepository->salvar($produto);
        }
        
        // 6. Salvar pedido e notificar
        $this->pedidoRepository->salvar($pedido);
        $this->notificacaoService->enviarConfirmacao($cliente, $pedido);
        
        return new CriarPedidoResult(
            $pedido->getId()->valor,
            $pedido->getTotal()->valor,
            $desconto->getPercentual(),
            "Pedido criado com sucesso"
        );
    }
    
    private function buscarProdutos(array $itens): array
    {
        $produtos = [];
        foreach ($itens as $item) {
            $produto = $this->produtoRepository->buscarPorId(new ProdutoId($item['produtoId']));
            $produtos[$item['produtoId']] = $produto;
        }
        return $produtos;
    }
}

// DTO de resposta
final readonly class CriarPedidoResult
{
    public function __construct(
        public string $pedidoId,
        public float $valorTotal,
        public float $percentualDesconto,
        public string $mensagem
    ) {}
}
```

## Domain Services Puros vs Impuros

Vladimir Khorikov, um dos autores mais respeitados sobre testes, faz uma distinção importante entre Domain Services "puros" e "impuros":

### Domain Services Puros

**Características:**
- Trabalham apenas com objetos de domínio.
- Não acessam infraestrutura externa.
- São completamente testáveis sem mocks.
- Podem ser injetados em Entities sem quebrar isolamento.

```php
// Domain Service PURO
class ValidadorCpf
{
    public function isValido(Cpf $cpf): bool
    {
        $numeros = preg_replace('/[^0-9]/', '', $cpf->valor);
        
        if (strlen($numeros) !== 11) {
            return false;
        }
        
        // Verifica sequências inválidas
        if (preg_match('/(\d)\1{10}/', $numeros)) {
            return false;
        }
        
        // Valida dígitos verificadores
        return $this->validarDigitosVerificadores($numeros);
    }
    
    private function validarDigitosVerificadores(string $numeros): bool
    {
        // Lógica pura de validação de CPF
        return true;
    }
}
```

### Domain Services Impuros

**Características:**
- Precisam acessar sistemas externos.
- Requerem mocks para testes.
- Não devem ser injetados em Entities.
- Mantêm a lógica de domínio mesmo dependendo de infraestrutura.

```php
// Domain Service IMPURO
class VerificadorPoliticaCredito
{
    public function __construct(
        private readonly HistoricoTransacoesRepository $historicoRepository,
        private readonly ServicoConsultaCredito $consultaCredito
    ) {}
    
    public function podeReceberCredito(Cliente $cliente, Dinheiro $valorSolicitado): ResultadoAnaliseCredito
    {
        // 1. Verificar limite baseado no perfil do cliente
        $limitePorPerfil = match($cliente->getTipo()) {
            TipoCliente::BRONZE => Dinheiro::reais(1000),
            TipoCliente::PRATA => Dinheiro::reais(5000),
            TipoCliente::OURO => Dinheiro::reais(15000),
            TipoCliente::DIAMANTE => Dinheiro::reais(50000)
        };
        
        // 2. Consultar histórico de transações
        $historico = $this->historicoRepository->buscarUltimasTransacoes($cliente->getId(), 12);
        $scoreHistorico = empty($historico) ? 0.5 : $this->calcularScore($historico);
        
        // 3. Consultar órgãos de proteção ao crédito
        $consultaExterna = $this->consultaCredito->consultarCpf($cliente->getCpf());
        
        // 4. Aplicar regras de decisão
        if ($consultaExterna->temRestricoes() || $scoreHistorico < 0.6) {
            return ResultadoAnaliseCredito::negado("Análise de risco não aprovada");
        }
        
        $limiteAprovado = $limitePorPerfil->multiplicar($scoreHistorico);
        
        return $valorSolicitado->isMenorOuIgual($limiteAprovado)
            ? ResultadoAnaliseCredito::aprovado($limiteAprovado, $scoreHistorico)
            : ResultadoAnaliseCredito::aprovadoComReducao($limiteAprovado, "Valor ajustado conforme análise");
    }
    
    private function calcularScore(array $transacoes): float
    {
        $pontuais = 0;
        foreach ($transacoes as $transacao) {
            if ($transacao->foiLiquidadaNoPrazo()) {
                $pontuais++;
            }
        }
        
        return $pontuais / count($transacoes);
    }
}
```

## Testando Domain Services vs Application Services

A testabilidade é diferente entre os dois tipos de serviços:

### Testando Domain Services (Puros)

```php
class CalculadoraDescontoTest extends TestCase
{
    public function test_cliente_ouro_deve_receber_desconto_correto(): void
    {
        $calculadora = new CalculadoraDesconto();
        $cliente = new Cliente(TipoCliente::OURO, 5);
        $produto = new Produto(CategoriaProduto::ELETRONICOS);
        
        $desconto = $calculadora->calcularDesconto($cliente, $produto);
        
        $this->assertEquals(0.23, $desconto->getPercentual()); // 15% + 5% + 3%
    }
}
```

### Testando Application Services

```php
class ProcessarPedidoApplicationServiceTest extends TestCase
{
    public function test_deve_criar_pedido_com_desconto_aplicado(): void
    {
        // Configurar mocks
        $clienteRepository = $this->createMock(ClienteRepository::class);
        $produtoRepository = $this->createMock(ProdutoRepository::class);
        $calculadoraDesconto = $this->createMock(CalculadoraDesconto::class);
        
        $service = new ProcessarPedidoApplicationService(
            $clienteRepository, $produtoRepository, /* outros mocks... */
        );
        
        $cliente = new Cliente(/* ... */);
        $produto = new Produto(/* ... */);
        $desconto = new Desconto(0.10, "Desconto cliente ouro");
        
        $clienteRepository->method('buscarPorId')->willReturn($cliente);
        $produtoRepository->method('buscarPorId')->willReturn($produto);
        $calculadoraDesconto->method('calcularDesconto')->willReturn($desconto);
        
        $command = new CriarPedidoCommand(/* dados do pedido */);
        
        $resultado = $service->criarPedido($command);
        
        $this->assertNotEmpty($resultado->pedidoId);
        $this->assertEquals(0.10, $resultado->percentualDesconto);
    }
}
```

## Anti-Patterns Comuns

### 1. Application Service com Lógica de Domínio

```php
// ERRADO: Application Service tomando decisões de negócio
class ProcessarPedidoApplicationService
{
    public function criarPedido(CriarPedidoCommand $command): void
    {
        $pedido = $this->pedidoRepository->buscarPorId($command->pedidoId);
        
        // LÓGICA DE DOMÍNIO no Application Service
        $desconto = 0;
        if ($pedido->getCliente()->getTipo() === TipoCliente::OURO) {
            $desconto = 0.15;
        } elseif ($pedido->getCliente()->getTipo() === TipoCliente::PRATA) {
            $desconto = 0.10;
        }
        
        $pedido->aplicarDesconto($desconto);
    }
}
```

**Solução:**
```php
// ✓ CORRETO: Delegar decisão para Domain Service
class ProcessarPedidoApplicationService
{
    public function criarPedido(CriarPedidoCommand $command): void
    {
        $pedido = $this->pedidoRepository->buscarPorId($command->pedidoId);
        
        // ✓ Delega a decisão para o Domain Service
        $desconto = $this->calculadoraDesconto->calcularDesconto(
            $pedido->getCliente(), 
            $pedido
        );
        
        $pedido->aplicarDesconto($desconto);
    }
}
```

### 2. Domain Service Fazendo Orquestração

```php
// ERRADO: Domain Service fazendo orquestração
class ProcessadorPedido // Domain Service?
{
    public function processar(Pedido $pedido): void
    {
        // Domain Service não deveria salvar no banco
        $this->pedidoRepository->salvar($pedido);
        
        // Domain Service não deveria enviar emails
        $this->emailService->enviarConfirmacao($pedido);
        
        // Domain Service não deveria chamar APIs externas
        $this->pagamentoApi->processarPagamento($pedido);
    }
}
```

## Conclusão

A distinção entre Domain Services e Application Services é fundamental para uma arquitetura DDD bem organizada:

### Domain Services:
- **Contêm lógica de negócio** que não pertence a nenhuma Entity específica.
- **Tomam decisões** baseadas em regras do domínio.
- **São testáveis** com objetos de domínio.
- **Representam conceitos** importantes do domínio.

### Application Services:
- **Orquestram operações** sem tomar decisões de negócio.
- **Coordenam** Domain Services, Aggregates e Infrastructure.
- **Gerenciam transações** e efeitos colaterais.
- **Servem como fachada** para casos de uso.

### Regra de Ouro:
**Se o código precisa tomar uma decisão de negócio, é Domain Service. Se apenas coordena operações, é Application Service.**

Quando implementados corretamente, estes serviços resultam em uma arquitetura mais limpa, testável e alinhada com os princípios do DDD, facilitando a manutenção e evolução do sistema.

No próximo artigo da série, exploraremos **Repositories - Abstraindo o acesso aos dados**, entendendo como implementar o padrão Repository de forma eficaz no DDD.

---

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)

+++start+++

## Anterior
[DDD: Agregados e Aggregate Roots - Garantindo consistência no modelo de domínio (Parte 5)](5.ddd-agregados-aggregate-roots)

## Próximo
[DDD: Repositories - Abstraindo o acesso aos dados (Parte 7)](7.ddd-repositories-abstraindo-acesso-dados)

+++end+++