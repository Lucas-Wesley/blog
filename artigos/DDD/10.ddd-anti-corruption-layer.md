---
title: "DDD: Anti-Corruption Layer - Protegendo seu domínio (Parte 10)"
date: "2025-05-16 14:00"
status: "published"
description: "Aprenda como implementar a Anti-Corruption Layer (ACL) para proteger seu modelo de domínio de influências externas e sistemas legados, mantendo a integridade arquitetural."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-anti-corruption-layer"
tags: ["DDD", "Anti-Corruption Layer", "ACL", "Integração", "Sistemas Legados", "Hexagonal Architecture"]
---

Este é o décimo artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos Context Mapping e os diferentes padrões de relacionamento entre contextos. Agora vamos nos aprofundar em um padrão específico e crucial: **Anti-Corruption Layer (ACL)**.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

A Anti-Corruption Layer é uma das ferramentas mais importantes para manter a integridade do seu modelo de domínio quando você precisa integrar com sistemas externos ou legados.

## O que é Anti-Corruption Layer?

**Anti-Corruption Layer** é um padrão de integração que cria uma camada isolada para traduzir entre dois modelos de domínio diferentes, protegendo o modelo interno das influências externas.

Eric Evans define:

> "Uma camada anti-corrupção é um meio de proporcionar aos clientes funcionalidade em termos de seu próprio modelo de domínio."

A ACL atua como um **tradutor** e **protetor**, garantindo que:
- Seu modelo de domínio permaneça limpo e consistente.
- Mudanças no sistema externo não quebrem seu sistema.
- A integração seja testável e mantível.

## Por que usar Anti-Corruption Layer?

### Problemas sem ACL

Sem uma ACL, a integração direta pode causar:

```php
<?php
// ✗ PROBLEMA: Modelo corrompido por sistema externo
class PedidoService
{
    public function criarPedido(CriarPedidoRequest $dados): void
    {
        // Nosso modelo limpo...
        $pedido = new Pedido($dados->clienteId, $dados->itens);
        
        // ...mas somos forçados a usar estruturas do sistema externo
        $clienteERP = $this->erpService->getCustomer($dados->clienteId);
        
        // Lógica de negócio misturada com tradução
        $pedidoERP = [
            'cust_id' => $clienteERP['id'],
            'cust_name' => $clienteERP['customer_name'],
            'order_date' => date('Y-m-d'),
            'items' => array_map(function($item) {
                return [
                    'product_code' => $item->produtoId,
                    'qty' => $item->quantidade,
                    'unit_price' => $item->preco * 100 // centavos
                ];
            }, $dados->itens)
        ];
        
        $this->erpService->createOrder($pedidoERP);
    }
}
```

### Soluções com ACL

Com ACL, mantemos nosso modelo limpo:

```php
<?php
// ✓ SOLUÇÃO: Modelo protegido por ACL
class PedidoService
{
    public function criarPedido(CriarPedidoRequest $dados): void
    {
        // Nosso modelo permanece limpo
        $cliente = $this->clienteService->buscarPorId($dados->clienteId);
        $pedido = new Pedido($cliente, $dados->itens);
        
        $this->pedidoRepository->salvar($pedido);
        
        // ACL cuida da tradução e integração
        $this->erpAdapter->registrarPedido($pedido);
    }
}

// Anti-Corruption Layer
class ErpAdapter
{
    public function registrarPedido(Pedido $pedido): void
    {
        // Traduz nosso modelo para o formato do ERP
        $pedidoERP = $this->traduzirPedido($pedido);
        $this->erpService->createOrder($pedidoERP);
    }
    
    private function traduzirPedido(Pedido $pedido): array
    {
        return [
            'cust_id' => $pedido->cliente->id,
            'cust_name' => $pedido->cliente->nome,
            'order_date' => $pedido->dataCriacao->format('Y-m-d'),
            'items' => array_map([$this, 'traduzirItem'], $pedido->itens)
        ];
    }
    
    private function traduzirItem(ItemPedido $item): array
    {
        return [
            'product_code' => $item->produto->codigo,
            'qty' => $item->quantidade,
            'unit_price' => round($item->precoUnitario->valor * 100)
        ];
    }
}
```

## Padrões de Implementação da ACL

### 1. Adapter Pattern

O padrão mais comum para sistemas com interfaces bem definidas:

```php
<?php
// Interface do nosso domínio
interface ClienteRepository
{
    public function buscarPorId(string $id): ?Cliente;
    public function salvar(Cliente $cliente): void;
}

// Adapter que implementa nossa interface
class ClienteERPAdapter implements ClienteRepository
{
    public function buscarPorId(string $id): ?Cliente
    {
        $customerERP = $this->erpService->getCustomer($id);
        return $this->traduzirCliente($customerERP);
    }
    
    public function salvar(Cliente $cliente): void
    {
        $customerERP = $this->traduzirParaERP($cliente);
        $this->erpService->updateCustomer($customerERP);
    }
    
    private function traduzirCliente(array $customerERP): Cliente
    {
        return new Cliente(
            $customerERP['id'],
            $customerERP['customer_name'],
            new Email($customerERP['email_address']),
            $customerERP['customer_type'] === 'P' ? TipoCliente::FISICA : TipoCliente::JURIDICA
        );
    }
    
    private function traduzirParaERP(Cliente $cliente): array
    {
        return [
            'id' => $cliente->id,
            'customer_name' => $cliente->nome,
            'email_address' => $cliente->email->valor,
            'customer_type' => $cliente->tipo === TipoCliente::FISICA ? 'P' : 'J'
        ];
    }
}
```

### 2. Gateway Pattern

Para acesso a recursos externos com tradução de dados:

```php
<?php
// Gateway para serviço de CEP externo
interface EnderecoGateway
{
    public function buscarPorCep(string $cep): Endereco;
}

class ViaCepGateway implements EnderecoGateway
{
    public function buscarPorCep(string $cep): Endereco
    {
        $cepLimpo = preg_replace('/\D/', '', $cep);
        
        if (strlen($cepLimpo) !== 8) {
            throw new Exception('CEP inválido');
        }
        
        $response = $this->httpClient->get("https://viacep.com.br/ws/{$cepLimpo}/json/");
        
        if (isset($response['erro'])) {
            throw new Exception('CEP não encontrado');
        }
        
        return $this->traduzirEndereco($response);
    }
    
    private function traduzirEndereco(array $viaCepResponse): Endereco
    {
        return new Endereco(
            str_replace('-', '', $viaCepResponse['cep']),
            $viaCepResponse['logradouro'],
            $viaCepResponse['bairro'],
            $viaCepResponse['localidade'],
            $viaCepResponse['uf']
        );
    }
}
```

## Tratamento de Erros na ACL

A ACL deve tratar erros do sistema externo e traduzi-los para o contexto do domínio:

```php
<?php
class PagamentoGatewayACL
{
    public function processarPagamento(Pagamento $pagamento): ResultadoPagamento
    {
        try {
            $resultado = $this->pagamentoExterno->pay([
                'amount' => $pagamento->getValor()->valor,
                'currency' => 'BRL',
                'card_token' => $pagamento->getCartao()->getToken()
            ]);
            
            return $this->traduzirResultado($resultado);
            
        } catch (Exception $error) {
            // Traduz erros externos para exceções do domínio
            throw $this->traduzirErro($error);
        }
    }
    
    private function traduzirErro(Exception $error): Exception
    {
        return match($error->getCode()) {
            'INVALID_CARD' => new CartaoInvalidoError('Cartão de crédito inválido'),
            'INSUFFICIENT_FUNDS' => new SaldoInsuficienteError('Saldo insuficiente'),
            'NETWORK_ERROR' => new ServicoIndisponivelError('Serviço de pagamento indisponível'),
            default => new PagamentoError("Erro no pagamento: {$error->getMessage()}")
        };
    }
}
```

## Testando a ACL

A ACL deve ser extensivamente testada para garantir a tradução correta:

```php
<?php
use PHPUnit\Framework\TestCase;

class ClienteERPAdapterTest extends TestCase
{
    public function testDeveTraduzirClienteDoERPCorretamente(): void
    {
        // Arrange
        $clienteERP = [
            'id' => '123',
            'customer_name' => 'João Silva',
            'email_address' => 'joao@email.com',
            'customer_type' => 'P'
        ];
        
        $this->mockERPService
            ->method('getCustomer')
            ->with('123')
            ->willReturn($clienteERP);
        
        // Act
        $cliente = $this->adapter->buscarPorId('123');
        
        // Assert
        $this->assertEquals('João Silva', $cliente->getNome());
        $this->assertEquals('joao@email.com', $cliente->getEmail()->valor);
        $this->assertEquals(TipoCliente::FISICA, $cliente->getTipo());
    }
}
```

## Benefícios da Anti-Corruption Layer

### 1. **Proteção do Modelo de Domínio**
Seu modelo interno permanece limpo e focado nas regras de negócio, sem ser contaminado por estruturas externas.

### 2. **Flexibilidade para Mudanças**
Alterações no sistema externo são absorvidas pela ACL, não impactando o restante do sistema.

### 3. **Testabilidade**
A ACL pode ser testada independentemente, e o sistema pode usar mocks durante os testes.

### 4. **Clareza de Responsabilidades**
Separação clara entre lógica de negócio e tradução/integração.

## Quando Usar ACL

### ✓ Use quando:
- Integração com sistemas legados.
- APIs externas com modelos diferentes.
- Múltiplos sistemas com estruturas divergentes.
- Proteção contra mudanças externas.
- Necessidade de tradução de dados complexa.

### ✗ Evite quando:
- Sistemas com modelos já compatíveis.
- Integrações simples e estáveis.
- O overhead não justifica o benefício.
- Time pequeno sem recursos para manutenção.

## Padrões Relacionados

A ACL frequentemente trabalha junto com outros padrões:

- **Repository Pattern**: Para abstração de persistência.
- **Gateway Pattern**: Para acesso a serviços externos.
- **Adapter Pattern**: Para tradução entre interfaces.
- **Facade Pattern**: Para unificar múltiplas operações.

## Conclusão

A Anti-Corruption Layer é uma ferramenta essencial para manter a integridade do modelo de domínio em sistemas que precisam integrar com sistemas externos ou legados.

### Pontos-chave:

1. **ACL protege seu modelo** de influências externas.
2. **Tradução bidirecional** entre modelos diferentes.
3. **Tratamento de erros** específico do domínio.
4. **Testabilidade** através de isolamento.
5. **Flexibilidade** para mudanças futuras.

Uma ACL bem implementada resulta em um modelo de domínio mais limpo, estável e testável, protegendo seu investimento em arquitetura limpa contra as inevitáveis mudanças e complexidades dos sistemas externos.

No próximo artigo da série, exploraremos **Specification Pattern**, que nos ajuda a encapsular regras de negócio complexas de forma elegante e reutilizável.

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)
- [Anti-Corruption Layer - Microsoft](https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer)

+++start+++

## Anterior
[DDD: Context Mapping - Mapeando as relações entre contextos (Parte 9)](9.ddd-context-mapping)

## Próximo
[DDD: Specification Pattern - Encapsulando regras de negócio complexas (Parte 11)](11.ddd-specification-pattern)

+++end+++