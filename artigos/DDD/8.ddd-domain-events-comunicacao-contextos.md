---
title: "DDD: Domain Events - Comunicação entre contextos (Parte 8)"
date: "2025-05-16 14:00"
status: "published"
description: "Entenda como Domain Events facilitam a comunicação desacoplada entre agregados e bounded contexts, implementando uma arquitetura orientada a eventos robusta e escalável."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-domain-events-comunicacao-contextos"
tags: ["DDD", "Domain Events", "Event-Driven Architecture", "Message Bus", "Integration Events", "Bounded Context"]
---

Este é o oitavo artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos os building blocks fundamentais do DDD. Agora chegou o momento de entender como **Domain Events** promovem comunicação desacoplada entre agregados e bounded contexts, criando arquiteturas orientadas a eventos robustas e escaláveis.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

Os Domain Events são fundamentais para resolver um dos maiores desafios do DDD: como manter consistência и coordenação entre diferentes partes do domínio sem criar acoplamento direto.

## O que são Domain Events?

**Domain Events** são fatos que aconteceram no passado e que são importantes para o domínio. Eles representam mudanças significativas no estado dos agregados que outras partes do sistema precisam conhecer e potencialmente reagir.

Como Martin Fowler define:

> "Um Domain Event captura a memória de algo interessante que afeta o domínio."

### Conceito Fundamental de Evento

Um **evento** é essencialmente uma **notificação sobre algo que já aconteceu**. Pense em eventos como registros históricos imutáveis que carregam informações sobre mudanças significativas no estado do sistema.

**Eventos são diferentes de estado**: enquanto o **estado** de um objeto responde "como as coisas estão agora", um **evento** responde "o que aconteceu e quando". Por exemplo, um pedido tem o estado "confirmado", mas o evento seria "pedido foi confirmado às 14:30 com valor de R$ 350,00".

#### Anatomia de um Evento

Todo evento bem estruturado contém:
- **Identificação do agregado** que gerou o evento.
- **Dados relevantes** sobre o que aconteceu.
- **Timestamp** de quando ocorreu.
- **Contexto necessário** para os handlers processarem.

```php
class PedidoConfirmadoEvent extends DomainEvent
{
    public function __construct(
        private readonly PedidoId $pedidoId,           // Qual pedido
        private readonly ClienteId $clienteId,         // De que cliente
        private readonly Dinheiro $valorTotal,         // Por quanto
        private readonly \DateTimeImmutable $confirmadoEm // Quando
    ) {
        parent::__construct(); // Inicializa ID único do evento
    }
    
    // Getters para expor os dados necessários...
}
```

### Como os Eventos Funcionam na Prática

Na prática, eventos funcionam como um **sistema de notificação interno** da aplicação. Quando algo significativo acontece, como um cliente fazer um pedido, um pagamento ser aprovado, ou um produto sair de estoque, o sistema "grita" essa informação para quem quiser escutar.

O processo é bem simples:

1. **Geração**: Quando um agregado executa uma ação importante, ele **registra** um evento internamente.
2. **Coleta**: O sistema coleta todos os eventos registrados.
3. **Persistência**: Salva o agregado no banco de dados primeiro.
4. **Dispatch**: Após salvar com sucesso, despacha os eventos para todos os handlers interessados.
5. **Processamento**: Cada handler executa sua lógica específica.

### Os Três Principais Usos Práticos

#### 1. **Capturar Mudanças Importantes**
Eventos capturam momentos significativos que outras partes do sistema precisam saber. Quando um item é adicionado ao pedido, isso pode interessar ao sistema de estoque, de frete, de analytics, etc.

#### 2. **Disparar Ações em Cascata**
Um único evento pode disparar múltiplas ações diferentes. Um "pedido confirmado" pode simultaneamente:
- Reservar estoque.
- Enviar email de confirmação.
- Iniciar processo de cobrança.
- Atualizar métricas.
- Preparar a separação no estoque.

#### 3. **Comunicação Entre Contextos**
Eventos permitem que diferentes partes do sistema (ou até microserviços) se comuniquem sem conhecer uns aos outros diretamente. O sistema de vendas não precisa conhecer o sistema de logística, ele só precisa publicar "pedido foi confirmado" e a logística reage automaticamente.

### Casos de Uso Concretos

#### **E-commerce Completo**
Quando um pedido é processado, cada etapa gera eventos que automaticamente disparam a próxima fase: validação de estoque, cálculo de frete, processamento de pagamento, preparação da entrega. É como uma linha de produção onde cada estação sinaliza para a próxima quando termina seu trabalho.

#### **Auditoria Automática**
Todos os eventos automaticamente geram registros de auditoria completos, capturando não só o que mudou, mas quando, por quem e em que contexto. É como ter um registro detalhado de tudo que acontece no sistema sem esforço extra.

#### **Notificações Inteligentes**
O sistema pode enviar diferentes tipos de notificação baseado no evento e no perfil do cliente: email para todos, SMS para pedidos altos, push para clientes premium. As regras de negócio ficam centralizadas e podem ser facilmente modificadas.

#### **Métricas de Negócio**
Eventos alimentam automaticamente dashboards e relatórios, coletando dados de conversão, receita, comportamento do usuário, picos de demanda. É como ter um analista virtual coletando dados 24/7.

## Por que Usar Domain Events?

### 1. Desacoplamento entre Agregados

Sem eventos, os agregados ficam acoplados diretamente a outros serviços, violando suas fronteiras. Com eventos, eles apenas "anunciam" o que aconteceu e outros componentes reagem conforme necessário.

```php
// ✗ Sem Eventos: Acoplamento direto
class Pedido {
    public function confirmar(EstoqueService $estoque, EmailService $email): void {
        $this->status = StatusPedido::CONFIRMADO;
        
        // Violação: pedido conhece outros contextos
        $estoque->reservar($this->itens);
        $email->enviarConfirmacao($this->clienteEmail);
    }
}

// ✓ Com Eventos: Desacoplado
class Pedido {
    public function confirmar(): void {
        $this->status = StatusPedido::CONFIRMADO;
        
        // Apenas anuncia o que aconteceu
        $this->raiseEvent(new PedidoConfirmadoEvent($this->id, $this->clienteId));
    }
}
```

### 2. Extensibilidade

Novos requisitos podem ser adicionados sem modificar código existente. Precisa integrar com analytics? Crie um handler. Precisa notificar por WhatsApp? Outro handler. O agregado original não muda.

### 3. Single Responsibility

Cada handler tem uma responsabilidade específica, mantendo o código organizado e fácil de testar. O agregado foca no domínio, handlers focam em efeitos colaterais.

## Quando e Como Usar Eventos

### **✓ Use Eventos quando:**

1. **Múltiplas ações** devem acontecer após uma mudança.
2. **Diferentes contextos** precisam saber sobre mudanças.
3. **Auditoria completa** é necessária.
4. **Processamento assíncrono** é desejável.
5. **Extensibilidade** é importante.

### **✗ Evite Eventos quando:**

1. **Performance é crítica** e você só precisa de uma ação simples.
2. **Sistemas muito pequenos** (o overhead não compensa).
3. **Mudanãs são irrelevantes** para outros componentes.

### A Regra de Ouro

**Se apenas uma coisa simples precisa acontecer após uma ação, use um método direto. Se múltiplas coisas precisam acontecer, ou se outras partes do sistema precisam saber sobre a mudança, use eventos.**

Eventos são fundamentalmente sobre **desacoplamento** e **extensibilidade**; eles permitem que seu sistema cresça organicamente sem que você precise modificar código existente toda vez que precisa adicionar uma nova funcionalidade.

## Domain Events vs Integration Events

### Domain Events
São eventos que ocorrem **dentro de um bounded context** e são processados **sincronamente** na mesma transação. Eles mantêm a consistência imediata dentro do contexto.

### Integration Events
São eventos que **cruzam boundaries** entre bounded contexts ou microserviços e são processados **assincronamente**. Eles permitem eventual consistency entre contextos diferentes.

A diferença é importante: Domain Events garantem que tudo aconteça na mesma transação, enquanto Integration Events permitem que sistemas distribuídos se comuniquem de forma resiliente.

## Padrões de Implementação

### 1. Immediate Dispatch
Eventos são despachados imediatamente quando gerados. Simples, mas pode causar efeitos colaterais na mesma transação.

### 2. Deferred Dispatch
Eventos são coletados e despachados após a persistência bem-sucedida. Mais seguro, pois só notifica sobre mudanças que foram realmente salvas.

### 3. Event Store
Eventos são persistidos e processados posteriormente, permitindo event sourcing e replay de eventos.

## Boas Práticas

### 1. Naming
- **Domain Events:** `AlgoAconteceuEvent` (verbo no passado)
- **Integration Events:** `AlgoAconteceuIntegrationEvent`

### 2. Event Data
- Inclua apenas dados necessários para os handlers.
- Evite objetos complexos, prefira IDs e valores primitivos.
- Para Integration Events, use DTOs serializáveis.

### 3. Error Handling
Implemente tratamento robusto de erros nos handlers, decidindo se deve continuar processando outros handlers ou parar em caso de falha.

### 4. Performance
Para Integration Events, considere processamento assíncrono usando filas para não impactar a performance da operação principal.

## Eventos em Memória

Algo que deve ser explorado para organizar o código em eventos, mas não lidar com a latência de redes, é criar eventos em memória na sua própria aplicação.
Padrões como Mediator, Observer, Pub/Sub são opções que podem ser implementadas em nível de aplicação. Por exemplo, você pode criar um Mediator para gerenciar eventos em memória e despachar para os handlers interessados.

## Quando NÃO Usar Eventos

1. **Para mudanças simples** que não interessam a outros agregados.
2. **Quando performance é crítica** e não há necessidade de desacoplamento.
3. **Em sistemas pequenos** onde o overhead não compensa.
4. **Para comunicação síncrona obrigatória** entre agregados.

## Características dos Domain Events

1. **Representam o passado**: Algo que já aconteceu.
2. **São imutáveis**: Uma vez criados, não podem ser alterados.
3. **Contêm dados relevantes**: Informações necessárias para os handlers.
4. **Nomeados com verbos no passado**: Ex: `PedidoCriadoEvent`, `PagamentoProcessadoEvent`.
5. **Fazem parte da Ubiquitous Language**: Especialistas do domínio os entendem.

## Conclusão

Domain Events são uma ferramenta poderosa para:

- **Desacoplar agregados** mantendo consistência.
- **Implementar side effects** de forma elegante.
- **Criar arquiteturas extensíveis** e testáveis.
- **Facilitar integração** entre bounded contexts.

A chave está em entender quando usar Domain Events vs Integration Events e escolher a estratégia de dispatch adequada para cada contexto.

**Resumindo na prática**: Eventos são como um sistema de notificação interno que permite que diferentes partes do seu sistema reajam automaticamente a mudanças importantes, sem que essas partes precisem conhecer umas às outras diretamente. Isso torna o código mais organizado, extensível e fácil de manter.

É importante lembrar que eventos não são bala de prata; use quando fizer sentido para o seu contexto, considerando o tradeoff entre flexibilidade e complexidade.

No próximo artigo, exploraremos **Context Mapping**, entendendo como mapear e gerenciar relacionamentos entre bounded contexts.

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)

---

+++start+++

## Anterior
[DDD: Repositories - Abstraindo o acesso aos dados (Parte 7)](7.ddd-repositories-abstraindo-acesso-dados)

## Próximo
[DDD: Context Mapping - Mapeando as relações entre contextos (Parte 9)](9.ddd-context-mapping)

+++end+++