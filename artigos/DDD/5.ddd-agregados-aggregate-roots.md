---
title: "DDD: Agregados e Aggregate Roots - Garantindo consistência no modelo de domínio (Parte 5)"
date: "2025-05-14 14:00"
status: "published"
description: "Descubra como usar Agregados e Aggregate Roots para manter a consistência do modelo de domínio, definir fronteiras transacionais e aplicar invariantes de negócio de forma eficaz."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-agregados-aggregate-roots"
tags: ["DDD", "Agregados", "Aggregate Roots", "Consistência", "Invariantes", "Transações"]
---

Este é o quinto artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos os conceitos fundamentais do DDD, a Linguagem Ubíqua, Bounded Contexts e os pilares do modelo de domínio com Value Objects e Entities. Agora chegou o momento de entender um dos conceitos mais importantes e, ao mesmo tempo, mais mal compreendidos do DDD: **Agregados e Aggregate Roots**.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

## O que são Agregados?

Um **Agregado** é um cluster (agrupamento) de objetos relacionados que devem ser tratados como uma única unidade para fins de mudanças de dados. Martin Fowler define de forma clara:

> "Um agregado DDD é um cluster de objetos de domínio que pode ser tratado como uma única unidade."

O conceito de Agregado não é sobre hierarquia ou relacionamentos de dados - é sobre **consistência** e **invariantes de negócio**. Um Agregado define uma fronteira de consistência ao redor de um grupo de objetos relacionados, garantindo que as regras de negócio sejam sempre respeitadas.

### A Confusão Comum

Muitos desenvolvedores pensam em Agregados como hierarquias de objetos ou relacionamentos de banco de dados. Essa é uma visão incorreta que leva a designs problemáticos. Como Derek Comartin diz:

> "Agregados não são sobre hierarquia e relacionamentos. São sobre comportamentos e invariantes que você precisa aplicar."

**Erro comum:**
```php
// Pensando apenas em relacionamentos
class Pedido  // Aggregate Root
{
    private Cliente $cliente;  // Relacionamento
    private array $itens;      // Relacionamento
    private Endereco $endereco; // Relacionamento
    
    // Apenas getters e setters - modelo anêmico
}
```

**Abordagem correta:**
```php
// Focando em comportamentos e invariantes
class Pedido  // Aggregate Root
{
    // Dados necessários para aplicar invariantes
    private PedidoId $id;
    private array $itens;
    private StatusPedido $status;
    private Dinheiro $total;
    
    // Comportamentos que aplicam regras de negócio
    public function adicionarItem(Produto $produto, int $quantidade): void
    {
        $this->garantirPedidoEditavel();
        $this->validarQuantidadeMaxima($quantidade);
        
        $item = new ItemPedido($produto, $quantidade);
        $this->itens[] = $item;
        $this->recalcularTotal();
    }
    
    // Invariantes do agregado
    private function garantirPedidoEditavel(): void
    {
        if ($this->status === StatusPedido::CONFIRMADO) {
            throw new InvalidOperationException("Pedido confirmado não pode ser editado");
        }
    }
}
```

## Aggregate Root: O Guardião da Consistência

Cada Agregado possui uma **Aggregate Root** (Raiz do Agregado) - uma Entity que serve como o único ponto de entrada para o Agregado. Como Eric Evans explica:

> "A raiz do agregado é a única entrada para qualquer acesso ao agregado, e ela deve garantir a integridade de todo o agregado."

### Responsabilidades da Aggregate Root

1. **Controlar acesso**: Todo acesso ao agregado deve passar pela root.
2. **Aplicar invariantes**: Garantir que regras de negócio sejam sempre respeitadas.
3. **Coordenar operações**: Orquestrar mudanças entre objetos internos.
4. **Manter identidade**: Fornecer identidade única para todo o agregado.

## Definindo Fronteiras de Agregados

Uma das decisões mais críticas no DDD é **onde desenhar as fronteiras dos agregados**. Fronteiras muito grandes causam problemas de concorrência e performance, enquanto fronteiras muito pequenas podem não conseguir aplicar invariantes adequadamente.

### Regras para Definir Fronteiras

1. **Invariantes sempre dentro do agregado**: Se uma regra precisa ser aplicada, os dados necessários devem estar no mesmo agregado.

2. **Transações não devem cruzar agregados**: Cada agregado é uma fronteira transacional.

3. **Agregados se referenciam por identidade**: Use IDs, não referências diretas.

4. **Modele ao redor de casos de uso**: Pense em como os dados são modificados juntos.

### Exemplo: Sistema de E-commerce

**Agregados Separados:**
```php
// Agregado 1: Produto
class Produto  // Aggregate Root
{
    private ProdutoId $id;
    private int $estoqueDisponivel;
    private StatusProduto $status;
    
    public function reduzirEstoque(int $quantidade): void
    {
        if ($this->estoqueDisponivel < $quantidade) {
            throw new InvalidOperationException("Estoque insuficiente");
        }
        
        $this->estoqueDisponivel -= $quantidade;
    }
    
    public function podeVender(int $quantidade): bool
    {
        return $this->status === StatusProduto::DISPONIVEL 
            && $this->estoqueDisponivel >= $quantidade;
    }
}

// Agregado 2: Pedido
class Pedido  // Aggregate Root
{
    private PedidoId $id;
    private ClienteId $clienteId;  // Referência por ID
    private array $itens;
    private StatusPedido $status;
    
    public function adicionarItem(ProdutoId $produtoId, int $quantidade, Dinheiro $precoUnitario): void
    {
        $this->garantirPedidoEditavel();
        
        $item = new ItemPedido($produtoId, $quantidade, $precoUnitario);
        $this->itens[] = $item;
    }
    
    public function confirmar(): void
    {
        if (empty($this->itens)) {
            throw new InvalidOperationException("Pedido vazio não pode ser confirmado");
        }
        $this->status = StatusPedido::CONFIRMADO;
    }
    
    private function garantirPedidoEditavel(): void
    {
        if ($this->status !== StatusPedido::RASCUNHO) {
            throw new InvalidOperationException("Pedido não pode ser editado");
        }
    }
    
    // Getters essenciais
    public function getItens(): array { return $this->itens; }
    public function getStatus(): StatusPedido { return $this->status; }
}

// Entity interna do agregado Pedido
class ItemPedido
{
    public function __construct(
        private readonly ProdutoId $produtoId,
        private int $quantidade,
        private readonly Dinheiro $precoUnitario
    ) {
        if ($quantidade <= 0) {
            throw new InvalidArgumentException("Quantidade deve ser positiva");
        }
    }
    
    public function getProdutoId(): ProdutoId { return $this->produtoId; }
    public function getQuantidade(): int { return $this->quantidade; }
}
```

## Domain Services: Coordenando Agregados

Quando uma operação envolve múltiplos agregados, usamos **Domain Services**. Eles coordenam operações entre agregados enquanto mantêm a lógica de domínio encapsulada.

```php
class ProcessarPedidoService
{
    public function __construct(
        private readonly ProdutoRepository $produtoRepository,
        private readonly PedidoRepository $pedidoRepository
    ) {}
    
    public function confirmarPedido(PedidoId $pedidoId): void
    {
        $pedido = $this->pedidoRepository->buscarPorId($pedidoId);
        
        if (!$pedido) {
            throw new PedidoNaoEncontradoException();
        }
        
        // Valida estoque para todos os itens
        foreach ($pedido->getItens() as $item) {
            $produto = $this->produtoRepository->buscarPorId($item->getProdutoId());
            
            if (!$produto) {
                throw new ProdutoNaoEncontradoException($item->getProdutoId());
            }
            
            if (!$produto->podeVender($item->getQuantidade())) {
                throw new EstoqueInsuficienteException(
                    $produto->getId(), 
                    $item->getQuantidade()
                );
            }
        }
        
        // Se chegou até aqui, tudo válido - reduz estoque e confirma pedido
        foreach ($pedido->getItens() as $item) {
            $produto = $this->produtoRepository->buscarPorId($item->getProdutoId());
            $produto->reduzirEstoque($item->getQuantidade());
            $this->produtoRepository->salvar($produto);
        }
        
        $pedido->confirmar();
        $this->pedidoRepository->salvar($pedido);
    }
}
```

Este Domain Service exemplifica perfeitamente a coordenação entre agregados. O `ProcessarPedidoService` não pertence a nenhum agregado específico porque sua responsabilidade é orquestrar uma operação complexa que envolve tanto o agregado **Pedido** quanto o **Produto**.

A operação segue um padrão de **validação prévia**: primeiro verifica se todos os produtos existem e têm estoque suficiente, só depois executa as alterações. Isso garante que não deixemos o sistema em estado inconsistente caso alguma validação falhe no meio do processo.

Note que o serviço não duplica lógica dos agregados: usa `$produto->podeVender()` e `$produto->reduzirEstoque()`, respeitando o encapsulamento. Também trabalha apenas com Aggregate Roots através de seus repositories, nunca acessando diretamente entidades internas como `ItemPedido`.

Esta abordagem mantém as responsabilidades bem definidas: cada agregado cuida de suas próprias regras de negócio, enquanto o Domain Service coordena as interações entre eles.

## Repositories: Um por Agregado

**Repositories** devem operar no nível do Agregado, não das entidades individuais. Cada Aggregate Root tem seu próprio Repository.

```php
interface PedidoRepository
{
    public function buscarPorId(PedidoId $id): ?Pedido;
    public function buscarPorCliente(ClienteId $clienteId): array;
    public function salvar(Pedido $pedido): void;
    public function remover(PedidoId $id): void;
}

interface ProdutoRepository
{
    public function buscarPorId(ProdutoId $id): ?Produto;
    public function buscarDisponiveis(): array;
    public function salvar(Produto $produto): void;
}

// Não fazer: Repository para entidade interna
interface ItemPedidoRepository  // ERRADO!
{
    // Itens são gerenciados pelo agregado Pedido
}
```

## Invariantes: As Regras de Ouro

**Invariantes** são as regras de negócio que devem sempre ser verdadeiras dentro de um agregado. Elas são a razão principal para a existência dos agregados.

### Tipos de Invariantes

1. **Invariantes Simples**: Aplicadas dentro de uma única entity.
2. **Invariantes de Agregado**: Precisam de múltiplos objetos para serem validadas.

### Exemplo: Agregado de Conta Corrente com Limite

```php
class ContaCorrente  // Aggregate Root
{
    private ContaId $id;
    private Dinheiro $saldo;
    private Dinheiro $limite;
    
    public function sacar(Dinheiro $valor): void
    {
        $novoSaldo = $this->saldo->subtrair($valor);
        
        // Invariante: Saldo + Limite sempre >= 0
        $saldoComLimite = $novoSaldo->somar($this->limite);
        if ($saldoComLimite->valor < 0) {
            throw new InvalidOperationException("Saque excede limite disponível");
        }
        
        $this->saldo = $novoSaldo;
    }
    
    public function ajustarLimite(Dinheiro $novoLimite): void
    {
        // Verifica se novo limite mantém invariante
        if ($this->saldo->valor < 0 && $novoLimite->valor < abs($this->saldo->valor)) {
            throw new InvalidOperationException("Limite insuficiente para saldo atual");
        }
        
        $this->limite = $novoLimite;
    }
}
```

## Problemas Comuns e Como Evitá-los

### 1. Agregados Muito Grandes

**Problema:**
```php
// ✗ Agregado muito grande
class Empresa  // Aggregate Root problemática
{
    private EmpresaId $id;
    private array $funcionarios;     // 1000+ funcionários
    private array $projetos;         // 100+ projetos  
    private array $produtos;         // 500+ produtos
    private array $vendas;           // 10000+ vendas
    
    // Carrega tudo na memória - performance terrível
    // Contenção em transações concorrentes
}
```

**Solução:**
```php
// ✓ Agregados menores e focados
class Empresa  // Aggregate Root
{
    private EmpresaId $id;
    private string $razaoSocial;
    private Cnpj $cnpj;
    private StatusEmpresa $status;
    
    // Apenas dados essenciais para invariantes da empresa
}

class Funcionario  // Aggregate Root separado
{
    private FuncionarioId $id;
    private EmpresaId $empresaId;  // Referência por ID
    private string $nome;
    private Cargo $cargo;
}
```

### 2. Falta de Invariantes Claras

**Problema:**
```php
// ✗ Sem invariantes claras
class Turma
{
    private array $alunos;
    
    public function adicionarAluno(Aluno $aluno): void
    {
        $this->alunos[] = $aluno;  // Sem validações
    }
}
```

**Solução:**
```php
// ✓ Invariantes bem definidas
class Turma  // Aggregate Root
{
    private const CAPACIDADE_MAXIMA = 30;
    
    private TurmaId $id;
    private array $alunos;
    private StatusTurma $status;
    
    public function adicionarAluno(Aluno $aluno): void
    {
        if ($this->status !== StatusTurma::ABERTA) {
            throw new InvalidOperationException("Turma não está aberta para inscrições");
        }
        
        if (count($this->alunos) >= self::CAPACIDADE_MAXIMA) {
            throw new InvalidOperationException("Turma já atingiu capacidade máxima");
        }
        
        $this->alunos[] = $aluno;
    }
}
```

### 3. Violação do Princípio "Um Repository por Agregado"

**Problema:**
```php
// ✗ Repositories para entidades internas
interface ItemPedidoRepository
{
    public function buscarPorPedido(PedidoId $pedidoId): array;
    public function salvar(ItemPedido $item): void;
}
```

**Solução:**
```php
// ✓ Repository apenas para Aggregate Root
interface PedidoRepository
{
    public function buscarPorId(PedidoId $id): ?Pedido;  // Traz o agregado completo
    public function salvar(Pedido $pedido): void;        // Salva o agregado completo
}
```

## Relacionamentos Entre Agregados

Agregados diferentes se referenciam **apenas por identidade**, nunca por referências diretas de objetos.

### Referências por Identidade

```php
class Pedido  // Aggregate Root
{
    private PedidoId $id;
    private ClienteId $clienteId;    // ✓ Referência por ID
    private EnderecoId $enderecoId;  // ✓ Referência por ID
    
    // ✗ NUNCA fazer isso:
    // private Cliente $cliente;     // Referência direta - ERRADO!
    // private Endereco $endereco;   // Referência direta - ERRADO!
}
```

### Navegação Entre Agregados

```php
// Busca agregados relacionados via repositories quando necessário
$cliente = $this->clienteRepository->buscarPorId($pedido->getClienteId());
$endereco = $this->enderecoRepository->buscarPorId($pedido->getEnderecoId());
```

## Conclusão

Agregados e Aggregate Roots são conceitos fundamentais do DDD que ajudam a manter a consistência e integridade do modelo de domínio. Eles não são sobre hierarquias ou relacionamentos de dados, mas sim sobre **comportamentos** e **invariantes** que precisam ser aplicados consistentemente.

### Pontos-chave para lembrar:

1. **Agregados definem fronteiras de consistência**, não estruturas de dados.
2. **Aggregate Roots são os únicos pontos de entrada** para modificar o agregado.
3. **Invariantes devem sempre ser aplicadas** dentro dos limites do agregado.
4. **Agregados se referenciam apenas por identidade**, nunca por objetos diretos.
5. **Um Repository por agregado**, operando sempre no nível da Aggregate Root.
6. **Domain Services coordenam operações** entre múltiplos agregados.
7. **Transações não devem cruzar fronteiras** de agregados.

Quando bem implementados, Agregados resultam em um modelo de domínio mais robusto, consistente e fácil de manter. Eles encapsulam a complexidade do negócio e garantem que as regras fundamentais sejam sempre respeitadas.

No próximo artigo da série, exploraremos **Domain Services vs Application Services**, entendendo quando usar cada tipo de serviço e como organizá-los adequadamente na arquitetura.

---

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)

+++start+++

## Anterior
[DDD: Value Objects e Entities - Pilares do modelo de domínio (Parte 4)](4.ddd-value-objects-entities-pilares-modelo-dominio)

## Próximo
[DDD: Domain Services vs Application Services - Organizando a lógica de negócio (Parte 6)](6.ddd-domain-services-vs-application-services)

+++end+++