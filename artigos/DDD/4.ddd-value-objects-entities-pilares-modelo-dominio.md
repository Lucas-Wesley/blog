---
title: "DDD: Value Objects e Entities - Pilares do modelo de domínio (Parte 4)"
date: "2025-05-13 14:00"
status: "published"
description: "Entenda a diferença fundamental entre Value Objects e Entities no DDD, quando usar cada um e como implementá-los corretamente para criar um modelo de domínio rico e expressivo."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-value-objects-entities-pilares-modelo-dominio"
tags: ["DDD", "Value Objects", "Entities", "Domain Model", "Identidade", "Imutabilidade"]
---

Este é o quarto artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos os conceitos fundamentais do DDD, a Linguagem Ubíqua e os Bounded Contexts. Agora chegou o momento de mergulhar nos elementos fundamentais que compõem um modelo de domínio rico: **Value Objects** e **Entities**.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

## O que são Value Objects e Entities?

No coração de qualquer modelo de domínio rico estão dois tipos principais de objetos: **Entities** (Entidades) e **Value Objects** (Objetos de Valor). A distinção entre eles é fundamental para criar um modelo de domínio expressivo e bem estruturado.

### A Questão da Identidade

A diferença fundamental entre Entities e Value Objects está na forma como determinamos sua **identidade**:

**Entities** são objetos que possuem uma **identidade única** que persiste ao longo do tempo. Mesmo que todos os seus atributos mudem, uma Entity continua sendo a mesma Entity se sua identidade permanecer.

**Value Objects** são definidos pelos seus **atributos** e não possuem identidade conceitual. Dois Value Objects com os mesmos atributos são considerados idênticos.

Como Eric Evans define no livro original de DDD:

> "Muitos objetos não são fundamentalmente definidos por seus atributos, mas sim por um fio de continuidade e identidade."

## Entities: Identidade e Ciclo de Vida

### Características das Entities

1. **Identidade única**: Cada Entity possui um identificador único que não muda durante sua vida útil.
2. **Ciclo de vida**: Entities são criadas, podem ser modificadas ao longo do tempo e eventualmente podem ser destruídas.
3. **Rastreabilidade**: É importante saber se duas instâncias representam a mesma Entity.
4. **Mutabilidade**: Entities podem ter seus atributos alterados mantendo sua identidade.

### Exemplo Prático: Usuário

```php
class Usuario
{
    private int $id;
    private string $nome;
    private string $email;
    private DateTimeImmutable $dataCriacao;
    
    public function __construct(int $id, string $nome, string $email)
    {
        $this->id = $id;
        $this->nome = $nome;
        $this->email = $email;
        $this->dataCriacao = new DateTimeImmutable();
    }
    
    // Um usuário mantém sua identidade mesmo se mudar nome ou email
    public function equals(Usuario $other): bool
    {
        return $this->id === $other->id;
    }
    
    public function alterarEmail(string $novoEmail): void
    {
        $this->email = $novoEmail;
    }
    
    public function getId(): int
    {
        return $this->id;
    }
}
```

## Value Objects: Descrição sem Identidade

Value Objects representam aspectos descritivos do domínio que não possuem identidade conceitual. Como Evans explica:

> "Um objeto que representa um aspecto descritivo do domínio sem identidade conceitual é chamado de Value Object."

### Características dos Value Objects

1. **Imutabilidade**: Uma vez criados, não podem ser modificados.
2. **Igualdade estrutural**: Dois Value Objects com os mesmos atributos são idênticos.
3. **Sem identidade**: Não há necessidade de rastreá-los ao longo do tempo.
4. **Funções side-effect free**: Operações que não causam efeitos colaterais.

### Exemplo Prático: Dinheiro

```php
final readonly class Dinheiro
{
    public function __construct(
        public float $valor,
        public Moeda $moeda
    ) {
        if ($valor < 0) {
            throw new InvalidArgumentException("Valor não pode ser negativo");
        }
    }
    
    public function somar(Dinheiro $outro): Dinheiro
    {
        if ($this->moeda !== $outro->moeda) {
            throw new InvalidArgumentException("Moedas diferentes");
        }
        return new Dinheiro($this->valor + $outro->valor, $this->moeda);
    }
    
    public function multiplicar(int $quantidade): Dinheiro
    {
        return new Dinheiro($this->valor * $quantidade, $this->moeda);
    }
    
    // Igualdade baseada nos atributos
    public function equals(Dinheiro $outro): bool
    {
        return $this->valor === $outro->valor && $this->moeda === $outro->moeda;
    }
    
    public static function reais(float $valor): self
    {
        return new self($valor, Moeda::BRL);
    }
}

enum Moeda: string
{
    case BRL = 'BRL';
    case USD = 'USD';
    case EUR = 'EUR';
}
```

## Como Decidir Entre Entity e Value Object

A decisão entre modelar algo como Entity ou Value Object depende do contexto e das necessidades do domínio.

### Perguntas para Entity

1. **"Preciso rastrear este objeto ao longo do tempo?"** - Se sim, provavelmente é uma Entity.
2. **"Duas instâncias com os mesmos atributos representam a mesma coisa?"** - Se não, provavelmente é uma Entity.
3. **"Este objeto tem um ciclo de vida importante para o negócio?"** - Se sim, provavelmente é uma Entity.

### Perguntas para Value Object

1. **"Posso substituir este objeto por outro com os mesmos atributos?"** - Se sim, provavelmente é um Value Object.
2. **"Este objeto descreve uma característica de algo?"** - Se sim, provavelmente é um Value Object.
3. **"A igualdade é baseada nos valores dos atributos?"** - Se sim, provavelmente é um Value Object.

## Combatendo a Obsessão por Primitivos

Value Objects são uma ferramenta poderosa para combater o que conhecemos como "Primitive Obsession" - o uso excessivo de tipos primitivos para representar conceitos de domínio.

### Problema: Método com muitos primitivos

```php
// Problemático: muitos string e int
function criarUsuario(
    string $nome, 
    string $email, 
    string $cep,
    string $cidade, 
    string $estado, 
    int $idade
): void {
    // Validações espalhadas
    if (empty($nome)) {
        throw new InvalidArgumentException("Nome inválido");
    }
    if (!str_contains($email, '@')) {
        throw new InvalidArgumentException("Email inválido");
    }
    // ... mais validações
}
```

### Solução: Value Objects expressivos

```php
// Melhor: Value Objects expressivos
function criarUsuario(Nome $nome, Email $email, Endereco $endereco, Idade $idade): void
{
    // Validações encapsuladas nos Value Objects
    // Código mais limpo e expressivo
}

final readonly class Email
{
    public function __construct(public string $valor)
    {
        if (!$this->isEmailValido($valor)) {
            throw new InvalidArgumentException("Email inválido: {$valor}");
        }
    }
    
    public function getDominio(): string
    {
        return substr($this->valor, strpos($this->valor, '@') + 1);
    }
    
    private function isEmailValido(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }
}
```

## Exemplo Completo: Sistema de E-commerce

```php
// Entity: Cliente
class Cliente
{
    public function __construct(
        private readonly ClienteId $id,
        private Nome $nome,
        private Email $email,
        private Endereco $endereco,
        private readonly DateTimeImmutable $dataCadastro = new DateTimeImmutable()
    ) {}
    
    public function atualizarEmail(Email $novoEmail): void
    {
        if ($novoEmail->equals($this->email)) {
            return; // Não há mudança
        }
        $this->email = $novoEmail;
    }
    
    public function isClienteAntigo(): bool
    {
        return $this->dataCadastro->diff(new DateTimeImmutable())->days > 365;
    }
    
    // Identidade baseada no ID
    public function equals(Cliente $outro): bool
    {
        return $this->id->equals($outro->id);
    }
}

// Value Object: ClienteId
final readonly class ClienteId
{
    public function __construct(public string $valor)
    {
        if (empty(trim($valor))) {
            throw new InvalidArgumentException("ID do cliente não pode ser vazio");
        }
    }
    
    public static function gerar(): self
    {
        return new self("CLI-" . strtoupper(substr(uniqid(), -8)));
    }
    
    public function equals(ClienteId $outro): bool
    {
        return $this->valor === $outro->valor;
    }
}
```

## Conclusão

Entities e Value Objects são os blocos fundamentais de qualquer modelo de domínio rico em DDD. A distinção entre eles - baseada na questão da identidade - é crucial para criar um modelo que reflita verdadeiramente as regras e conceitos do negócio.

**Entities** representam conceitos que têm identidade e ciclo de vida, devendo ser rastreados ao longo do tempo. Elas encapsulam comportamentos do domínio e mantêm sua identidade mesmo quando seus atributos mudam.

**Value Objects** representam conceitos descritivos sem identidade, sendo definidos pelos seus atributos. São imutáveis, combatem a obsessão por primitivos e tornam o código mais expressivo e seguro.

A combinação inteligente de Entities e Value Objects resulta em um modelo de domínio mais expressivo, com regras de negócio bem encapsuladas e código mais limpo e testável. Lembre-se: o contexto sempre importa na decisão entre Entity e Value Object.

No próximo artigo da série, exploraremos **Agregados e Aggregate Roots**, aprendendo como agrupar Entities e Value Objects relacionados para manter a consistência e integridade do modelo de domínio.

+++start+++

## Anterior
[DDD: Bounded Contexts - Delimitando contextos (Parte 3)](3.ddd-bounded-contexts-delimitando-contextos)

## Próximo
[DDD: Agregados e Aggregate Roots - Garantindo consistência no modelo de domínio (Parte 5)](5.ddd-agregados-aggregate-roots)

+++end+++
