---
title: "DDD: Context Mapping - Mapeando as relações entre contextos (Parte 9)"
date: "2025-05-16 14:00"
status: "published"
description: "Entenda como mapear as relações entre Bounded Contexts no DDD, identificar padrões de integração e gerenciar dependências entre diferentes contextos de domínio."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-context-mapping"
tags: ["DDD", "Context Mapping", "Bounded Contexts", "Integração", "Padrões de Integração"]
---

Este é o nono artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos Bounded Contexts e como eles delimitam fronteiras claras entre diferentes áreas de negócio. Agora chegou o momento de entender como esses contextos se relacionam: **Context Mapping**.

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

Context Mapping é uma das práticas mais estratégicas do DDD, mas frequentemente negligenciada. Não é apenas sobre integração técnica, é sobre **relacionamentos organizacionais** e **política de equipes**.

## O que é Context Mapping?

**Context Mapping** é a prática de mapear os relacionamentos entre diferentes Bounded Contexts. Eric Evans define:

> "Um Context Map é uma representação visual dos Bounded Contexts e dos relacionamentos entre eles."

Context Mapping vai além de um diagrama. É uma ferramenta para:
- **Identificar dependências** entre contextos.
- **Visualizar fluxos de dados** e comunicação.
- **Entender política organizacional** и estrutura de equipes.
- **Planejar estratégias de integração**.

### Por que Context Mapping é Fundamental?

Na prática, Context Mapping resolve problemas reais que encontramos em sistemas complexos:

**1. Evita Acoplamento Desnecessário**
Sem um mapa claro, diferentes contextos acabam se acoplando diretamente, criando dependências que dificultam a evolução independente de cada área.

**2. Reflete a Realidade Organizacional**
Os relacionamentos entre contextos espelham como as equipes realmente trabalham juntas. Um Context Map revela a verdadeira estrutura de comunicação da empresa.

**3. Facilita a Tomada de Decisão**
Quando você precisa integrar dois sistemas, o Context Map mostra qual padrão de relacionamento faz mais sentido considerando política, tecnologia e pessoas.

## Os Padrões de Relacionamento

### 1. Customer-Supplier (Cliente-Fornecedor)

O padrão mais comum: um contexto (upstream) fornece serviços para outro (downstream). O contexto fornecedor tem prioridade e define as regras.

**Quando usar:**
- Um contexto claramente serve outro.
- Há uma hierarquia natural entre as equipes.
- O contexto upstream tem mais estabilidade.

**Exemplo prático:**
O contexto de Catálogo fornece dados de produtos para o contexto de Carrinho de Compras. O Catálogo define a estrutura dos dados de produto, e o Carrinho se adapta a essa estrutura.

```php
// Catálogo (Upstream) define a interface
interface CatalogoService
{
    public function obterProduto(string $id): ProdutoDTO;
}

// Carrinho (Downstream) consome a interface
class CarrinhoService
{
    public function __construct(private CatalogoService $catalogoService) {}
    
    public function adicionarItem(string $produtoId): void
    {
        $produto = $this->catalogoService->obterProduto($produtoId);
        // Lógica do carrinho...
    }
}
```

### 2. Conformist (Conformista)

O contexto downstream aceita totalmente o modelo do upstream, mesmo que não seja ideal para seu domínio.

**Quando usar:**
- Integrando com sistemas externos que você não controla.
- O custo de criar uma camada de tradução é muito alto.
- O modelo externo é "suficientemente bom".

**Exemplo prático:**
Seu sistema precisa integrar com uma API de pagamento externa. Você aceita os formatos e estruturas que a API define, mesmo que não sejam ideais para seu domínio.

### 3. Anticorruption Layer (Camada Anticorrupção)

O contexto downstream protege seu modelo através de uma camada de tradução que converte entre os modelos.

**Quando usar:**
- O modelo externo é muito diferente do seu domínio.
- Você quer proteger seu modelo de mudanças externas.
- A qualidade do modelo externo é questionável.

**Exemplo prático:**
Integração com um ERP legado que usa códigos crípticos e formatos estranhos. Você cria uma camada que traduz os dados do ERP para objetos ricos do seu domínio.

### 4. Shared Kernel (Núcleo Compartilhado)

Dois contextos compartilham um pequeno modelo comum. **Use com muito cuidado!**

**Quando usar (raramente):**
- Dois contextos são mantidos pela mesma equipe.
- Há um modelo realmente comum e estável.
- Os benefícios superam os riscos de acoplamento.

**Cuidados:**
- Mudanças afetam múltiplos contextos.
- Requer coordenação entre equipes.
- Pode virar um "God Object" distribuído.

### 5. Open Host Service (Serviço de Host Aberto)

Um contexto oferece um protocolo público bem definido para integração com múltiplos consumidores.

**Quando usar:**
- Múltiplos contextos precisam dos mesmos dados.
- Você quer criar uma API pública.
- O contexto serve como plataforma para outros.

**Exemplo prático:**
Um serviço de notificações que oferece APIs REST padronizadas para envio de email, SMS e push notifications, usado por vários outros contextos.

## Context Mapping na Prática: E-commerce

Vamos mapear um sistema real de e-commerce:

### **Contextos Identificados:**
1. **Catálogo**: Gerencia produtos, categorias e preços.
2. **Carrinho**: Gerencia itens temporários do cliente.
3. **Pedidos**: Processa pedidos e pagamentos.
4. **Estoque**: Controla disponibilidade de produtos.
5. **Entrega**: Gerencia logística e envios.
6. **Clientes**: Gerencia dados e preferências dos clientes.

### **Relacionamentos Mapeados:**

**Catálogo → Carrinho (Customer-Supplier)**
O Catálogo fornece dados de produtos para o Carrinho. O Catálogo tem prioridade porque define preços e disponibilidade.

**Carrinho → Pedidos (Customer-Supplier)**
Quando o cliente finaliza a compra, o Carrinho transfere os dados para Pedidos. Pedidos valida e processa as informações.

**Pedidos → Estoque (Customer-Supplier)**
Pedidos consulta e reserva itens no Estoque. O Estoque controla as regras de disponibilidade.

**Pedidos → Entrega (Customer-Supplier)**
Após confirmação do pagamento, Pedidos cria ordens de entrega. Entrega define prazos e custos.

**Clientes → Pedidos (Open Host Service)**
Clientes oferece uma API para consulta de dados pessoais, usada por Pedidos e outros contextos.

### **Benefícios do Mapeamento:**

1. **Clareza de Responsabilidades**: Cada contexto tem suas responsabilidades bem definidas.
2. **Evolução Independente**: Contextos podem evoluir sem quebrar outros.
3. **Facilita Testes**: Interfaces claras permitem mocks e testes isolados.
4. **Reduz Conflitos**: Times sabem exatamente como se comunicar.

## Armadilhas Comuns do Context Mapping

### **1. Big Ball of Mud Disfarçado**
Criar muitos Shared Kernels que na verdade acoplam tudo. Prefira Customer-Supplier ou Anticorruption Layer.

### **2. Over-Engineering**
Criar camadas de tradução complexas quando uma simples interface seria suficiente.

### **3. Ignorar a Realidade Organizacional**
Mapear contextos ideais que não refletem como as equipes realmente trabalham.

### **4. Context Map Estático**
Não atualizar o mapa conforme o sistema e a organização evoluem.

## Ferramentas e Visualização

### **Diagramas Simples**
Use ferramentas como Miro, Lucidchart ou até mesmo desenhos à mão para criar diagramas visuais dos relacionamentos.

### **Documentação Viva**
Mantenha o Context Map atualizado como parte da documentação arquitetural. Revise periodicamente em reuniões de arquitetura.

### **Validação Contínua**
Periodicamente, questione:
- Os relacionamentos ainda fazem sentido?
- Novos contextos surgiram?
- Algum contexto cresceu demais?

## Context Mapping e Estrutura Organizacional

O Context Mapping reflete a Lei de Conway: a estrutura do software espelha a estrutura de comunicação da organização.

### **Implicações Práticas:**

**Customer-Supplier** funciona quando há hierarquia clara entre equipes ou quando uma equipe é claramente prestadora de serviço para outra.

**Shared Kernel** só funciona se as equipes trabalham muito próximas e têm processos de coordenação estabelecidos.

**Anticorruption Layer** é essencial quando integrando com equipes externas ou legados.

**Open Host Service** funciona quando uma equipe tem vocação de plataforma e recursos para manter APIs públicas.

## Evoluindo o Context Map

Context Maps não são estáticos. Eles evoluem conforme:

- **Organização muda**: Novas equipes, reestruturações.
- **Negócio evolui**: Novos produtos, mercados.
- **Tecnologia amadurece**: Novos padrões, ferramentas.
- **Aprendizado**: Melhor entendimento do domínio.

### **Sinais de que o Context Map precisa evoluir:**

1. **Muitas exceções** nas integrações.
2. **Conflitos frequentes** entre equipes.
3. **Mudanãs em cascata** afetando múltiplos contextos.
4. **Performance degradada** por overhead de integração.

## Conclusão

Context Mapping é uma ferramenta estratégica fundamental no DDD que vai além de diagramas técnicos. É sobre **entender relacionamentos**, **gerenciar dependências** e **alinhar tecnologia com organização**.

### Pontos-chave:

1. **Context Mapping reflete a realidade organizacional**.
2. **Cada padrão de relacionamento** tem implicações diferentes.
3. **Shared Kernel** deve ser usado com parcimônia.
4. **Anticorruption Layer** protege o modelo de domínio.
5. **Context Map evolui** com o tempo.
6. **Validação contínua** identifica problemas arquiteturais.

Um Context Map bem desenhado resulta em integração mais limpa, evolução independente e redução de conflitos entre equipes. Mais importante, ele torna visível como seu software reflete (e pode influenciar) a estrutura da sua organização.

Context Mapping não é apenas uma ferramenta técnica, é uma ferramenta de gestão que ajuda a alinhar tecnologia, pessoas e processos.

No próximo artigo da série, exploraremos **Anti-Corruption Layer** em detalhes, entendendo como proteger seu domínio de influências externas.

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software, Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Context Mapping, Martin Fowler](https://martinfowler.com/bliki/BoundedContext.html)
- [Team Topologies, Matthew Skelton & Manuel Pais](https://teamtopologies.com/)
- [Patterns, Principles, and Practices of Domain-Driven Design, Scott Millett](https://www.amazon.com/Patterns-Principles-Practices-Domain-Driven-Design/dp/1118714709)
- [Context Mapping, DDD Community](https://github.com/ddd-crew/context-mapping)
- [Implementing Domain-Driven Design, Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)

+++start+++

## Anterior
[DDD: Domain Events - Comunicação entre contextos (Parte 8)](8.ddd-domain-events-comunicacao-contextos)

## Próximo
[DDD: Anti-Corruption Layer - Protegendo seu domínio (Parte 10)](10.ddd-anti-corruption-layer)

+++end+++