---
title: "DDD: Specification Pattern - Encapsulando regras de negócio complexas (Parte 11)"
date: "2025-05-17 14:00"
status: "published"
description: "Aprenda como usar o Specification Pattern para encapsular, combinar e reutilizar regras de negócio complexas, mantendo o código limpo e testável."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-specification-pattern"
tags: ["DDD", "Specification Pattern", "Regras de Negócio", "Domain Logic"]
---

Este é o décimo primeiro artigo da série sobre Domain-Driven Design. Nos artigos anteriores exploramos padrões de integração e proteção do modelo de domínio. Agora vamos mergulhar em um padrão fundamental para lidar com regras de negócio complexas: o **Specification Pattern**.

Conceitos técnicos são melhor explicados através de exemplos práticos. Por isso, em vez de explicações teóricas complexas, utilizarei exemplos de código comentados para demonstrar os conceitos. Acredito que essa abordagem torna mais claros os conceitos abstratos.

O Specification Pattern é uma ferramenta poderosa que nos permite encapsular lógica de domínio complexa de forma elegante e reutilizável. É especialmente útil quando lidamos com combinações intrincadas de critérios e regras condicionais que, sem uma estrutura adequada, podem rapidamente se tornar código confuso e difícil de manter.

## O que é Specification Pattern?

O **Specification Pattern** é um padrão de design que encapsula regras de negócio em objetos reutilizáveis que podem ser facilmente combinados usando operadores lógicos. Eric Evans descreve no livro original de DDD:

> "Uma especificação é um predicado que determina se um objeto satisfaz alguns critérios."

Este padrão resolve três categorias principais de problemas no design de software:

**Validação:** Verificar se um objeto atende a determinados critérios antes de uma operação.
**Seleção:** Filtrar conjuntos de objetos baseados em regras específicas.
**Construção:** Especificar como criar objetos que satisfaçam determinados requisitos.

### O Contexto do Problema

Imagine um sistema de e-commerce onde você precisa determinar quais produtos são elegíveis para uma promoção sazonal. As regras podem incluir diversos critérios: o produto deve estar ativo, ter estoque mínimo, pertencer a categorias específicas, estar numa faixa de preço, não ter estado em promoção recentemente, entre outros.

Sem uma estrutura adequada, essas regras frequentemente acabam espalhadas pelo código, duplicadas em vários lugares, difíceis de testar isoladamente e praticamente impossíveis de combinar de forma flexível.

## O Problema: Regras de Negócio Espalhadas

Vamos examinar como essas regras complexas tipicamente aparecem no código quando não usamos o Specification Pattern. Este exemplo ilustra os problemas comuns que enfrentamos:

```php
<?php

/**
 * ✗ PROBLEMA: Lógica espalhada e difícil de manter
 * Este exemplo mostra como regras de negócio complexas 
 * frequentemente aparecem misturadas no código
 */
class ProdutoService
{
    private ProdutoRepository $produtoRepository;
    
    public function __construct(ProdutoRepository $produtoRepository)
    {
        $this->produtoRepository = $produtoRepository;
    }
    
    public function buscarProdutosElegiveisPromocao(): array
    {
        // Buscar todos os produtos do repositório
        $produtos = $this->produtoRepository->buscarTodos();
        $produtosElegiveis = [];
        
        foreach ($produtos as $produto) {
            // Regra 1: Produto deve estar ativo no sistema
            if (!$produto->isAtivo()) {
                continue; // Pula para o próximo produto
            }
            
            // Regra 2: Deve ter estoque mínimo de 10 unidades
            if ($produto->getQuantidadeEstoque() <= 10) {
                continue; // Produto sem estoque suficiente
            }
            
            // Regra 3: Categoria deve ser eletrônicos ou casa
            $categoriasElegiveis = ['eletronicos', 'casa'];
            $categoriaProduto = strtolower($produto->getCategoria()->getNome());
            if (!in_array($categoriaProduto, $categoriasElegiveis)) {
                continue; // Categoria não elegível
            }
            
            // Regra 4: Preço entre R$ 50 e R$ 500
            $preco = $produto->getPreco()->getValor();
            if ($preco < 50 || $preco > 500) {
                continue; // Fora da faixa de preço
            }
            
            // Regra 5: Não pode estar em promoção há menos de 30 dias
            if ($produto->getUltimaPromocao() !== null) {
                $diasSemPromocao = $produto->getUltimaPromocao()->diff(new DateTime())->days;
                if ($diasSemPromocao < 30) {
                    continue; // Promoção muito recente
                }
            }
            
            // Se passou por todas as validações, adiciona à lista
            $produtosElegiveis[] = $produto;
        }
        
        return $produtosElegiveis;
    }
    
    public function validarProdutoParaPromocao(Produto $produto): bool
    {
        // ✗ PROBLEMA: Duplicação da mesma lógica!
        // Aqui teríamos que repetir todas as regras novamente
        if (!$produto->isAtivo()) {
            return false;
        }
        
        if ($produto->getQuantidadeEstoque() <= 10) {
            return false;
        }
        
        // ... repetir todas as outras regras
        return true;
    }
}
```

Este código apresenta vários problemas sérios:

- **Duplicação**: As mesmas regras aparecem em múltiplos métodos.
- **Dificuldade de teste**: É difícil testar regras individuais isoladamente.
- **Baixa flexibilidade**: Combinar regras de formas diferentes requer reescrever código.
- **Violação do princípio Single Responsibility**: A classe está lidando com múltiplas responsabilidades.

## A Solução: Implementando Specification Pattern

O Specification Pattern resolve estes problemas encapsulando cada regra em uma classe específica que pode ser facilmente testada, reutilizada e combinada. Vamos implementar a solução:

### 1. Interface Base da Specification

Primeiro, criamos a interface que define o contrato básico de uma specification. Esta interface deve permitir tanto verificar se um objeto satisfaz os critérios quanto combinar specifications:

```php
<?php

/**
 * Interface base que define o contrato para todas as Specifications
 * Permite verificar critérios e combinar regras usando operadores lógicos
 */
interface Specification
{
    /**
     * Verifica se um item satisfaz os critérios desta specification
     * @param mixed $item - Objeto a ser verificado
     * @return bool - true se satisfaz os critérios, false caso contrário
     */
    public function isSatisfiedBy($item): bool;
    
    /**
     * Combina esta specification com outra usando operador AND
     * @param Specification $other - Outra specification para combinar
     * @return Specification - Nova specification que representa esta AND outra
     */
    public function and(Specification $other): Specification;
    
    /**
     * Combina esta specification com outra usando operador OR
     * @param Specification $other - Outra specification para combinar
     * @return Specification - Nova specification que representa esta OR outra
     */
    public function or(Specification $other): Specification;
    
    /**
     * Nega esta specification (operador NOT)
     * @return Specification - Nova specification que representa NOT desta
     */
    public function not(): Specification;
}
```

### 2. Classe Base Abstrata

Em seguida, criamos uma classe abstrata que implementa os operadores lógicos, permitindo que as specifications concretas foquem apenas em sua lógica específica:

```php
<?php

/**
 * Classe abstrata que implementa os operadores lógicos comuns
 * Evita duplicação de código nas specifications concretas
 */
abstract class AbstractSpecification implements Specification
{
    /**
     * Método abstrato que cada specification concreta deve implementar
     * Contém a lógica específica de validação de cada regra de negócio
     */
    abstract public function isSatisfiedBy($item): bool;
    
    /**
     * Implementa o operador AND - ambas specifications devem ser verdadeiras
     */
    public function and(Specification $other): Specification
    {
        return new AndSpecification($this, $other);
    }
    
    /**
     * Implementa o operador OR - pelo menos uma specification deve ser verdadeira
     */
    public function or(Specification $other): Specification
    {
        return new OrSpecification($this, $other);
    }
    
    /**
     * Implementa o operador NOT - inverte o resultado da specification
     */
    public function not(): Specification
    {
        return new NotSpecification($this);
    }
}

/**
 * Specification que implementa o operador lógico AND
 * Só retorna true se ambas as specifications forem satisfeitas
 */
class AndSpecification extends AbstractSpecification
{
    private Specification $left;   // Primeira specification
    private Specification $right;  // Segunda specification
    
    public function __construct(Specification $left, Specification $right)
    {
        $this->left = $left;
        $this->right = $right;
    }
    
    public function isSatisfiedBy($item): bool
    {
        // Ambas devem retornar true
        return $this->left->isSatisfiedBy($item) && $this->right->isSatisfiedBy($item);
    }
}

/**
 * Specification que implementa o operador lógico OR
 * Retorna true se pelo menos uma das specifications for satisfeita
 */
class OrSpecification extends AbstractSpecification
{
    private Specification $left;
    private Specification $right;
    
    public function __construct(Specification $left, Specification $right)
    {
        $this->left = $left;
        $this->right = $right;
    }
    
    public function isSatisfiedBy($item): bool
    {
        // Pelo menos uma deve retornar true
        return $this->left->isSatisfiedBy($item) || $this->right->isSatisfiedBy($item);
    }
}

/**
 * Specification que implementa o operador lógico NOT
 * Inverte o resultado da specification original
 */
class NotSpecification extends AbstractSpecification
{
    private Specification $specification;
    
    public function __construct(Specification $specification)
    {
        $this->specification = $specification;
    }
    
    public function isSatisfiedBy($item): bool
    {
        // Inverte o resultado da specification original
        return !$this->specification->isSatisfiedBy($item);
    }
}
```

**Por que precisamos da classe abstrata?** Embora apenas a interface seria suficiente para definir o contrato, a classe abstrata evita duplicação de código. Sem ela, cada specification concreta teria que implementar os métodos `and()`, `or()` e `not()` repetidamente. A `AbstractSpecification` implementa esses operadores lógicos uma única vez, permitindo que as classes filhas se concentrem apenas na lógica de validação específica.

### 3. Specifications Específicas para Regras de Negócio

Agora implementamos cada regra de negócio como uma specification específica. Cada classe encapsula uma responsabilidade única e bem definida:

```php
<?php

/**
 * Specification que verifica se um produto está ativo
 * Encapsula a regra: "Produto deve estar ativo no sistema"
 */
class ProdutoAtivoSpecification extends AbstractSpecification
{
    public function isSatisfiedBy($produto): bool
    {
        // Validação de tipo - garante que é um produto
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        // Regra de negócio específica: produto ativo
        return $produto->isAtivo();
    }
}

/**
 * Specification que verifica se um produto tem estoque suficiente
 * Permite configurar o estoque mínimo necessário
 */
class ProdutoComEstoqueSpecification extends AbstractSpecification
{
    private int $estoqueMinimo;
    
    /**
     * @param int $estoqueMinimo - Quantidade mínima de estoque necessária
     */
    public function __construct(int $estoqueMinimo = 10)
    {
        $this->estoqueMinimo = $estoqueMinimo;
    }
    
    public function isSatisfiedBy($produto): bool
    {
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        // Verifica se o estoque atual é maior que o mínimo exigido
        return $produto->getQuantidadeEstoque() > $this->estoqueMinimo;
    }
}

/**
 * Specification que verifica se um produto pertence a categorias permitidas
 * Permite definir uma lista de categorias elegíveis
 */
class ProdutoCategoriaSpecification extends AbstractSpecification
{
    private array $categoriasPermitidas;
    
    /**
     * @param array $categoriasPermitidas - Lista de categorias que são permitidas
     */
    public function __construct(array $categoriasPermitidas)
    {
        // Normaliza as categorias para lowercase para comparação case-insensitive
        $this->categoriasPermitidas = array_map('strtolower', $categoriasPermitidas);
    }
    
    public function isSatisfiedBy($produto): bool
    {
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        // Normaliza a categoria do produto e verifica se está na lista permitida
        $categoriaProduto = strtolower($produto->getCategoria()->getNome());
        return in_array($categoriaProduto, $this->categoriasPermitidas);
    }
}

/**
 * Specification que verifica se um produto está numa faixa de preço específica
 * Permite definir preço mínimo e máximo
 */
class ProdutoFaixaPrecoSpecification extends AbstractSpecification
{
    private float $precoMinimo;
    private float $precoMaximo;
    
    /**
     * @param float $precoMinimo - Preço mínimo permitido
     * @param float $precoMaximo - Preço máximo permitido
     */
    public function __construct(float $precoMinimo, float $precoMaximo)
    {
        // Validação dos parâmetros de entrada
        if ($precoMinimo > $precoMaximo) {
            throw new InvalidArgumentException('Preço mínimo não pode ser maior que preço máximo');
        }
        
        $this->precoMinimo = $precoMinimo;
        $this->precoMaximo = $precoMaximo;
    }
    
    public function isSatisfiedBy($produto): bool
    {
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        // Verifica se o preço está dentro da faixa definida (inclusive)
        $preco = $produto->getPreco()->getValor();
        return $preco >= $this->precoMinimo && $preco <= $this->precoMaximo;
    }
}

/**
 * Specification que verifica se um produto não teve promoção recente
 * Garante um intervalo mínimo entre promoções
 */
class ProdutoSemPromocaoRecenteSpecification extends AbstractSpecification
{
    private int $diasMinimos;
    
    /**
     * @param int $diasMinimos - Número mínimo de dias sem promoção
     */
    public function __construct(int $diasMinimos = 30)
    {
        $this->diasMinimos = $diasMinimos;
    }
    
    public function isSatisfiedBy($produto): bool
    {
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        $ultimaPromocao = $produto->getUltimaPromocao();
        
        // Se nunca teve promoção, pode ter uma agora
        if ($ultimaPromocao === null) {
            return true;
        }
        
        // Calcula quantos dias se passaram desde a última promoção
        $diasSemPromocao = $ultimaPromocao->diff(new DateTime())->days;
        
        // Retorna true se já passou tempo suficiente
        return $diasSemPromocao >= $this->diasMinimos;
    }
}
```

### 4. Refatorando o Service com Specifications

Agora podemos refatorar nosso service original para usar as specifications. O código fica muito mais limpo, flexível e testável:

```php
<?php

/**
 * ✓ SOLUÇÃO: Service refatorado usando Specification Pattern
 * Código mais limpo, testável e flexível
 */
class ProdutoService
{
    private ProdutoRepository $produtoRepository;
    
    public function __construct(ProdutoRepository $produtoRepository)
    {
        $this->produtoRepository = $produtoRepository;
    }
    
    /**
     * Busca produtos elegíveis para promoção usando specifications combinadas
     */
    public function buscarProdutosElegiveisPromocao(): array
    {
        // Cria a specification combinada para promoção
        $specPromocao = $this->criarSpecificationPromocao();
        
        // Busca todos os produtos
        $produtos = $this->produtoRepository->buscarTodos();
        $produtosElegiveis = [];
        
        // Aplica a specification para filtrar os produtos
        foreach ($produtos as $produto) {
            if ($specPromocao->isSatisfiedBy($produto)) {
                $produtosElegiveis[] = $produto;
            }
        }
        
        return $produtosElegiveis;
    }
    
    /**
     * Valida se um produto específico é elegível para promoção
     * Reutiliza a mesma lógica sem duplicação
     */
    public function validarProdutoParaPromocao(Produto $produto): bool
    {
        $specPromocao = $this->criarSpecificationPromocao();
        return $specPromocao->isSatisfiedBy($produto);
    }
    
    /**
     * Cria a specification combinada para promoção
     * Centraliza todas as regras em um local
     */
    private function criarSpecificationPromocao(): Specification
    {
        // Cria cada specification individual
        $ativo = new ProdutoAtivoSpecification();
        $comEstoque = new ProdutoComEstoqueSpecification(10);
        $categoriaElegivel = new ProdutoCategoriaSpecification(['eletronicos', 'casa']);
        $precoAdequado = new ProdutoFaixaPrecoSpecification(50, 500);
        $semPromocaoRecente = new ProdutoSemPromocaoRecenteSpecification(30);
        
        // Combina todas as specifications usando AND
        // Todas as condições devem ser verdadeiras
        return $ativo
            ->and($comEstoque)
            ->and($categoriaElegivel)
            ->and($precoAdequado)
            ->and($semPromocaoRecente);
    }
    
    /**
     * Exemplo de flexibilidade: criar diferentes combinações facilmente
     * Busca produtos premium usando critérios diferentes
     */
    public function buscarProdutosPremium(): array
    {
        $specPremium = $this->criarSpecificationPremium();
        $produtos = $this->produtoRepository->buscarTodos();
        $produtosPremium = [];
        
        foreach ($produtos as $produto) {
            if ($specPremium->isSatisfiedBy($produto)) {
                $produtosPremium[] = $produto;
            }
        }
        
        return $produtosPremium;
    }
    
    /**
     * Specification para produtos premium - demonstra reutilização
     */
    private function criarSpecificationPremium(): Specification
    {
        // Reutiliza specifications existentes com parâmetros diferentes
        $ativo = new ProdutoAtivoSpecification();
        $precoAlto = new ProdutoFaixaPrecoSpecification(300, 2000);
        $categoriaLuxo = new ProdutoCategoriaSpecification(['eletronicos', 'joias']);
        
        // Combinação diferente para produtos premium
        return $ativo->and($precoAlto)->and($categoriaLuxo);
    }
}
```

## Vantagens do Specification Pattern

A implementação do Specification Pattern traz benefícios significativos para o código:

### 1. Testabilidade Melhorada

Cada specification pode ser testada isoladamente, tornando os testes mais focados e fáceis de escrever. Conseguimos testar individualmente cada regra de negócio sem depender de outras partes do sistema.

### 2. Reutilização e Composição

As specifications podem ser facilmente reutilizadas e combinadas de diferentes formas para atender a diversos cenários de negócio. Não precisamos duplicar lógica, simplesmente combinamos specifications existentes de maneiras diferentes.

### 3. Expressividade do Código

O código resultante é muito mais expressivo e legível. Métodos como `criarSpecificationPromocao()` deixam claro exatamente quais critérios estão sendo aplicados, facilitando a compreensão do código.

### 4. Facilidade de Manutenção

Mudanças nas regras de negócio podem ser facilmente implementadas modificando specifications específicas, sem afetar outras partes do sistema. Isso reduz significativamente o risco de bugs.

## Padrões Avançados com Specifications

### Specifications Contextuais

Podemos criar specifications que consideram o contexto específico da operação, como o cliente que está fazendo a compra:

```php
<?php

/**
 * Specification que considera o contexto do cliente para aplicar regras específicas
 * Demonstra como specifications podem ser contextuais
 */
class ProdutoElegivelParaClienteSpecification extends AbstractSpecification
{
    private Cliente $cliente;
    
    public function __construct(Cliente $cliente)
    {
        $this->cliente = $cliente;
    }
    
    public function isSatisfiedBy($produto): bool
    {
        if (!$produto instanceof Produto) {
            throw new InvalidArgumentException('Item deve ser uma instância de Produto');
        }
        
        // Clientes VIP têm acesso a todos os produtos ativos
        if ($this->cliente->isVip()) {
            return $produto->isAtivo();
        }
        
        // Clientes regulares só têm acesso a produtos básicos e intermediários
        $categoriasPermitidas = ['basico', 'intermediario'];
        $categoria = strtolower($produto->getCategoria()->getNome());
        
        return $produto->isAtivo() && in_array($categoria, $categoriasPermitidas);
    }
}
```

## Quando Usar o Specification Pattern

O Specification Pattern é especialmente útil em cenários específicos do desenvolvimento de software:

### Cenários Ideais

**Regras de Validação Complexas:** Quando você tem múltiplas condições que precisam ser verificadas antes de uma operação importante.

**Filtros Dinâmicos:** Quando usuários podem combinar diferentes critérios de busca de forma flexível, criando consultas personalizadas.

**Regras de Negócio Reutilizáveis:** Quando as mesmas regras aparecem em múltiplos contextos e você precisa evitar duplicação.

**Evolução Frequente de Regras:** Quando as regras de negócio mudam com frequência e você precisa de flexibilidade para adaptar rapidamente.

### Cuidados e Limitações

**Complexidade Adicional:** Para regras simples, o pattern pode adicionar complexidade desnecessária ao código.

**Performance:** Se não implementado cuidadosamente, pode levar a múltiplas consultas ao banco de dados ou processamento excessivo.

**Curva de Aprendizado:** Desenvolvedores precisam entender o padrão para usá-lo efetivamente, o que pode exigir treinamento.

## Conclusão

O Specification Pattern é uma ferramenta poderosa para organizar e gerenciar regras de negócio complexas em aplicações Domain-Driven Design. Ele promove código mais limpo, testável e flexível, permitindo que regras de negócio sejam facilmente combinadas e reutilizadas.

A implementação cuidadosa deste padrão resulta em um código mais expressivo que reflete diretamente as regras do domínio, facilitando tanto a manutenção quanto a evolução do sistema. As specifications tornam as regras de negócio explícitas e verificáveis, contribuindo para um modelo de domínio mais robusto.

No próximo artigo da série, exploraremos CQRS e Event Sourcing, padrões que complementam muito bem o Specification Pattern em arquiteturas mais complexas, especialmente quando precisamos lidar com cenários de alta performance e escalabilidade.

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com.br/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Specification Pattern - Martin Fowler](https://martinfowler.com/apsupp/spec.pdf)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com.br/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)
- [Enterprise Patterns and MDA - Jim Arlow](https://www.amazon.com.br/Enterprise-Patterns-MDA-Building-Better/dp/032111230X)

+++start+++

## Anterior
[DDD: Anti-Corruption Layer - Protegendo seu domínio (Parte 10)](10.ddd-anti-corruption-layer)

## Próximo
[DDD: CQRS e Event Sourcing - Separando comandos e consultas (Parte 12)](12.ddd-cqrs-event-sourcing)

+++end+++