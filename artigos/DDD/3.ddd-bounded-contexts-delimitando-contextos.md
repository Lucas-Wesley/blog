---
title: "DDD: Bounded Contexts - Delimitando contextos (Parte 3)"
date: "2025-05-13 14:00"
status: "published"
description: "Entenda como os Bounded Contexts no DDD ajudam a dividir sistemas complexos em partes menores e gerenciáveis, definindo fronteiras claras para modelos de domínio."
autor: "Lucas Wesley Moreira Tinta"
category: "DDD"
slug: "ddd-bounded-contexts-delimitando-contextos"
tags: ["DDD", "Bounded Context", "Contexto Delimitado", "Microservices", "Arquitetura"]
---

Este é o terceiro artigo da série sobre Domain-Driven Design. Nos artigos anteriores, exploramos os conceitos fundamentais do DDD e a importância da Linguagem Ubíqua. Agora, vamos mergulhar em um dos conceitos mais poderosos e práticos do DDD: os **Bounded Contexts** (Contextos Delimitados).

Conceitos técnicos quase sempre são mais bem explicados com exemplos práticos. Muitas vezes, em vez de tentar explicar com texto complicado, vou usar exemplos de códigos com comentários para explicar o que está acontecendo. Acredito que isso torna mais claros os conceitos mais abstratos.

Sistemas complexos tornam inviável aplicar um modelo único para todo o sistema. Os Bounded Contexts são a resposta do DDD para esse problema, permitindo que dividamos sistemas grandes em partes menores e mais gerenciáveis.

## O que são Bounded Contexts?

Um Bounded Context é um padrão que define uma fronteira organizacional e linguística explícita dentro da qual um modelo de domínio específico é definido e aplicável. Em outras palavras, é o limite dentro do qual uma determinada linguagem ubíqua faz sentido e onde um conjunto específico de conceitos, terminologia e regras de negócio se aplicam.

Como Eric Evans define:

> "Bounded Context delimita a aplicabilidade de um modelo particular. Dentro do contexto, todos os termos e frases da Linguagem Ubíqua têm significado específico, e o modelo reflete a linguagem com precisão."

Tudo começa pela linguagem ubíqua. Ela, na prática, vai definir onde começa и termina um Bounded Context. Pode parecer um conceito simples, "Ah, preciso falar a linguagem do meu cliente, isso é óbvio, eu já sei disso...". Saber é fácil, mas usar da forma correta é o que realmente importa. Negligenciando essa etapa, o restante do processo será todo errado ou, no mínimo, mal-entendido.

## O Problema: A Busca pelo Modelo Único

### Cenário Real: E-commerce

Imagine um sistema de e-commerce onde tentamos usar um único modelo para "Cliente". Diferentes partes do sistema têm necessidades diferentes:

**No contexto de Vendas:**
- Cliente precisa de: nome, CPF, histórico de compras, dados de cobrança.
- Regras: desconto por fidelidade, limite de crédito.

**No contexto de Marketing:**
- Cliente precisa de: preferências, comportamento de navegação, segmentação.
- Regras: campanhas direcionadas, análise de persona.

**No contexto de Suporte:**
- Cliente precisa de: tickets abertos, histórico de problemas, satisfação.
- Regras: escalação de tickets, SLA de atendimento.

**No contexto de Logística:**
- Cliente precisa de: endereços de entrega, preferências de entrega.
- Regras: cálculo de frete, zonas de entrega.

### O Resultado: O Modelo Frankenstein

Tentando atender a todos os contextos com um modelo único, acabamos com algo assim:

```php
<?php

// O "modelo que faz tudo"
class Cliente
{
    public function __construct(
        // Dados pessoais (Vendas)
        private string $nome,
        private string $cpf,
        private string $email,
        private string $telefone,
        // Dados financeiros (Vendas)
        private float $limiteCredito,
        private array $historicoCompras,
        // Dados de marketing (Marketing)
        private array $preferencias,
        private ComportamentoNavegacao $comportamentoNavegacao,
        private array $segmentos,
        // Dados de suporte (Suporte)
        private array $tickets,
        private int $nivelSatisfacao,
        private array $historicoProblemas,
        // Dados logísticos (Logística)
        private array $enderecosEntrega,
        private PreferenciaEntrega $preferenciasEntrega,
        private ZonaEntrega $zonaEntrega
    ) {}
    
    // Métodos misturados
    public function calcularDesconto(): float { /* vendas */ }
    public function enviarCampanha(): void { /* marketing */ }
    public function escalarTicket(): void { /* suporte */ }
    public function calcularFrete(): float { /* logística */ }
}
```

Este modelo traz problemas como:
- **Acoplamento alto**: Mudança em um contexto afeta todos os outros.
- **Responsabilidades misturadas**: Uma classe faz tudo.
- **Complexidade crescente**: Cada novo requisito torna o modelo mais complexo.
- **Equipes bloqueadas**: Mudanças requerem coordenação entre todas as equipes.

## A Solução: Bounded Contexts

### Dividindo em Contextos

Aplicando Bounded Contexts, dividimos o sistema em contextos menores e mais coesos:

```php
<?php

// Contexto de Vendas
namespace Vendas;

readonly class Dinheiro
{
    public function __construct(
        public float $valor,
        public string $moeda = 'BRL'
    ) {}
    
    public function menorOuIgualA(Dinheiro $outro): bool
    {
        return $this->valor <= $outro->valor;
    }
    
    public static function zero(string $moeda = 'BRL'): self
    {
        return new self(0, $moeda);
    }
}

class Cliente
{
    public function __construct(
        private string $id,
        private string $nome,
        private string $cpf,
        private Dinheiro $limiteCredito,
        private array $historicoCompras = []
    ) {}
    
    public function calcularDesconto(): Dinheiro
    {
        // Lógica específica de vendas
        return count($this->historicoCompras) > 10 
            ? new Dinheiro(100, 'BRL') 
            : Dinheiro::zero('BRL');
    }
    
    public function podeComprar(Dinheiro $valor): bool
    {
        return $valor->menorOuIgualA($this->limiteCredito);
    }
}

// Contexto de Marketing
namespace Marketing;

class Segmento
{
    public function __construct(
        private string $nome,
        private array $criterios
    ) {}
}

class Campanha
{
    public function __construct(
        private string $nome,
        private array $segmentosAlvo
    ) {}
    
    public function direcionadaPara(Segmento $segmento): bool
    {
        return in_array($segmento, $this->segmentosAlvo);
    }
}

class Cliente
{
    public function __construct(
        private string $id,
        private string $email,
        private array $preferencias = [],
        private array $segmentos = []
    ) {}
    
    public function adicionarSegmento(Segmento $segmento): void
    {
        if (!$this->pertenceSegmento($segmento)) {
            $this->segmentos[] = $segmento;
        }
    }
    
    public function pertenceSegmento(Segmento $segmento): bool
    {
        return in_array($segmento, $this->segmentos);
    }
    
    public function elegivelParaCampanha(Campanha $campanha): bool
    {
        foreach ($this->segmentos as $segmento) {
            if ($campanha->direcionadaPara($segmento)) {
                return true;
            }
        }
        return false;
    }
}

// Contexto de Suporte
namespace Suporte;

enum Prioridade: string
{
    case BAIXA = 'baixa';
    case MEDIA = 'media';
    case ALTA = 'alta';
    case CRITICA = 'critica';
}

class NivelSatisfacao
{
    public function __construct(
        private int $pontuacao
    ) {}
    
    public function isAlto(): bool
    {
        return $this->pontuacao >= 8;
    }
}

class Ticket
{
    public function __construct(
        public string $clienteId,
        public string $descricao,
        public Prioridade $prioridade
    ) {}
}

class Cliente
{
    public function __construct(
        private string $id,
        private string $nome,
        private string $email,
        private array $tickets = [],
        private NivelSatisfacao $nivelSatisfacao = new NivelSatisfacao(5)
    ) {}
    
    public function abrirTicket(string $descricao, Prioridade $prioridade): Ticket
    {
        $ticket = new Ticket($this->id, $descricao, $prioridade);
        $this->tickets[] = $ticket;
        return $ticket;
    }
    
    public function isClienteVip(): bool
    {
        return $this->nivelSatisfacao->isAlto() && count($this->tickets) < 3;
    }
}
```

## Características dos Bounded Contexts

### 1. Autonomia
Cada contexto é autônomo e pode evoluir independentemente:

```php
<?php

// Contexto de Vendas pode mudar sua lógica sem afetar Marketing
namespace Vendas;

class Cliente
{
    // Vendas decide usar pontos de fidelidade em vez de desconto direto
    public function calcularDesconto(): Dinheiro
    {
        return $this->pontosFidelidade->converterParaDesconto();
    }
}

// Marketing continua funcionando normalmente
namespace Marketing;

class Cliente
{
    // Não é afetado pela mudança em Vendas
    public function elegivelParaCampanha(Campanha $campanha): bool
    {
        foreach ($this->segmentos as $segmento) {
            if ($campanha->direcionadaPara($segmento)) {
                return true;
            }
        }
        return false;
    }
}
```

### 2. Linguagem Específica
Cada contexto tem sua própria linguagem ubíqua:

```php
<?php

// No contexto de Biblioteca
namespace Biblioteca;

class Usuario
{
    private array $emprestimosAtivos;
    
    public function podeEmprestar(): bool
    {
        return count($this->emprestimosAtivos) < 3;
    }
}

// No contexto de Cafeteria (na mesma biblioteca)
namespace Cafeteria;

class Cliente
{
    private Dinheiro $contaCredito;
    
    public function podeComprar(Dinheiro $valor): bool
    {
        return $this->contaCredito->maiorOuIgualA($valor);
    }
}
```

### 3. Modelos Diferentes para o Mesmo Conceito
O mesmo conceito real pode ter modelos completamente diferentes:

```php
<?php
// Sistema Hospitalar

// Contexto de Consultas
namespace Consultas;

class Sintoma
{
    public function __construct(
        public string $descricao,
        public string $intensidade
    ) {}
}

class HistoricoMedico
{
    public function __construct(
        public array $procedimentosAnteriores = []
    ) {}
}

class Consulta
{
    public function __construct(
        public Paciente $paciente,
        public Medico $medico,
        public DateTime $data
    ) {}
}

class Paciente
{
    public function __construct(
        private array $sintomas = [],
        private HistoricoMedico $historicoMedico = new HistoricoMedico()
    ) {}
    
    public function agendarConsulta(Medico $medico, DateTime $data): Consulta
    {
        return new Consulta($this, $medico, $data);
    }
}

// Contexto de Faturamento
namespace Faturamento;

class DadosCobranca
{
    public function __construct(
        public string $nome,
        public string $endereco
    ) {}
}

class Dinheiro
{
    public function __construct(
        public float $valor,
        public string $moeda = 'BRL'
    ) {}
}

class Paciente
{
    public function __construct(
        private DadosCobranca $dadosCobranca,
        private Convenio $convenio
    ) {}
    
    public function calcularValorConsulta(Procedimento $procedimento): Dinheiro
    {
        return $this->convenio->calcularCobertura($procedimento);
    }
}

// Contexto de Farmácia
namespace Farmacia;

class Alergia
{
    public function __construct(
        public string $substancia
    ) {}
}

class Medicamento
{
    public function __construct(
        public string $nome,
        public array $principiosAtivos
    ) {}
}

class Paciente
{
    public function __construct(
        private array $alergias = [],
        private array $medicamentosAtuais = []
    ) {}
    
    public function podeTomarMedicamento(Medicamento $medicamento): bool
    {
        return !$this->temAlergiaA($medicamento) && 
               !$this->temInteracao($medicamento);
    }
    
    private function temAlergiaA(Medicamento $medicamento): bool
    {
        foreach ($this->alergias as $alergia) {
            foreach ($medicamento->principiosAtivos as $principio) {
                if ($alergia->substancia === $principio) {
                    return true;
                }
            }
        }
        return false;
    }
    
    private function temInteracao(Medicamento $medicamento): bool
    {
        // Lógica de verificação de interações medicamentosas
        return false;
    }
}
```

## Identificando Bounded Contexts

### Sinais de que Você Precisa de Novos Contextos

#### 1. Dados "Inúteis" nos Testes
```php
<?php
// Sinal de problema
class CalculoFreteTest extends TestCase
{
    public function testDeveCalcularFreteCorretamente(): void
    {
        $cliente = new Cliente(
            'João',
            '123.456.789-00',
            'joao@email.com',
            1000, // limite crédito - não usado neste teste
            [], // histórico compras - não usado
            [], // preferências marketing - não usado
            5, // satisfação - não usado
            new Endereco('SP', 'São Paulo', '01234-567')
        );
        
        $frete = $this->calculadoraFrete->calcular($cliente);
        
        $this->assertEquals(15.00, $frete->valor);
    }
}
```

#### 2. Modelos Inchados
```php
<?php

// Modelo que faz muita coisa
class Produto
{
    // Dados do catálogo
    private string $nome;
    private string $descricao;
    private Categoria $categoria;
    
    // Dados de estoque
    private int $quantidadeEstoque;
    private int $estoqueMinimo;
    
    // Dados de preço
    private Dinheiro $preco;
    private array $promocoes;
    
    // Dados de avaliação
    private array $avaliacoes;
    private float $notaMedia;
    
    // Dados de recomendação
    private string $algoritmoRecomendacao;
    private array $produtosRelacionados;
    
    // Métodos misturados - muitas responsabilidades!
    public function atualizarEstoque(): void { }
    public function calcularPrecoComDesconto(): Dinheiro { }
    public function adicionarAvaliacao(): void { }
    public function recomendarProdutos(): array { }
}
```

#### 3. Mudanças que Afetam Múltiplas Áreas
Se uma mudança simples requer alteração em várias partes não relacionadas do sistema, provavelmente os contextos não estão bem definidos.

### Técnicas para Descobrir Contextos

#### 1. Event Storming
Mapear eventos de domínio ajuda a identificar contextos naturais:

```
Timeline de E-commerce:
[Cliente Registrou] → [Produto Visualizado] → [Item Adicionado ao Carrinho] 
→ [Checkout Iniciado] → [Pagamento Processado] → [Pedido Confirmado] 
→ [Item Separado] → [Produto Enviado] → [Entrega Realizada]

Contextos identificados:
- Catálogo: Produto Visualizado
- Carrinho: Item Adicionado, Checkout Iniciado  
- Pagamento: Pagamento Processado
- Pedidos: Pedido Confirmado
- Estoque: Item Separado
- Logística: Produto Enviado, Entrega Realizada
```

#### 2. Análise de Linguagem
Preste atenção quando a mesma palavra significa coisas diferentes:

```
"Pedido" em diferentes contextos:

Vendas: "Pedido é uma solicitação de compra do cliente"
- Pedido tem itens, preço, desconto

Estoque: "Pedido é uma lista de itens para separação"  
- Pedido tem localização no estoque, quantidade

Logística: "Pedido é um pacote para entrega"
- Pedido tem endereço, peso, dimensões

Financeiro: "Pedido é uma transação financeira"
- Pedido tem forma de pagamento, valor, imposto
```

#### 3. Análise Organizacional
Contextos frequentemente seguem limites organizacionais:

```
Organização de E-commerce:

Equipe de Produto → Contexto de Catálogo
Equipe de Vendas → Contexto de Pedidos  
Equipe de Marketing → Contexto de CRM
Equipe de Logística → Contexto de Entrega
Equipe Financeira → Contexto de Pagamentos
```

## Bounded Contexts e Microservices

A relação entre Bounded Contexts e microservices é uma das aplicações mais práticas e valiosas do DDD na arquitetura moderna. Embora não sejam conceitos idênticos, existe uma sobreposição natural que torna os Bounded Contexts excelentes candidatos para se tornarem microservices independentes.

### Por que Bounded Contexts São Ideais para Microservices?

**Coesão Natural:** Cada Bounded Context agrupa funcionalidades relacionadas que fazem sentido juntas. Isso resulta em microservices mais coesos, onde todas as funcionalidades trabalham em direção ao mesmo objetivo de negócio.

**Baixo Acoplamento:** Como os contextos são projetados para serem independentes, eles naturalmente minimizam dependências externas. Isso é fundamental para microservices que precisam ser deployados e mantidos independentemente.

**Limites Claros:** As fronteiras bem definidas dos contextos facilitam a definição de APIs e contratos entre serviços, reduzindo ambiguidades sobre responsabilidades.

**Ownership Definido:** Cada contexto pode ser mantido por uma equipe específica, facilitando a organização e responsabilidade no desenvolvimento de microservices.

### Mapeamento Direto: Um Contexto = Um Microservice

A abordagem mais direta é mapear cada Bounded Context para um microservice dedicado. Isso funciona bem quando os contextos são suficientemente grandes e independentes:

```php
<?php
// Microservice de Catálogo
class CatalogoService
{
    // Implementa completamente o Bounded Context de Catálogo
    
    public function buscarProdutos(FiltrosProduto $filtros): array
    {
        // Toda lógica relacionada à busca de produtos
        // incluindo: filtros, ordenação, paginação, cache
    }
    
    public function adicionarProduto(Produto $produto): void
    {
        // Validações específicas do contexto de catálogo:
        // - Categoria válida
        // - Preço dentro dos limites permitidos  
        // - Descrição atende aos padrões da empresa
    }
    
    public function atualizarDisponibilidade(string $produtoId, bool $disponivel): void
    {
        // Lógica específica de disponibilidade no catálogo
    }
}

// Microservice de Pedidos independente
class PedidosService
{
    // Implementa completamente o Bounded Context de Pedidos
    
    public function criarPedido(array $itens): Pedido
    {
        // Lógica específica de criação de pedidos:
        // - Validação de itens
        // - Cálculo de totais
        // - Aplicação de regras de negócio
    }
    
    public function confirmarPedido(string $pedidoId): void
    {
        // Regras específicas de confirmação:
        // - Verificação de estoque (via evento)
        // - Validação de pagamento
        // - Criação de workflow de fulfillment
    }
}
```

### Comunicação Entre Contextos: Eventos Assíncronos

Uma das grandes vantagens de usar Bounded Contexts como base para microservices é que a comunicação entre eles já foi pensada para ser independente. A forma mais eficaz é através de **eventos de domínio**:

**Por que Eventos?**
- **Desacoplamento temporal:** O serviço que envia o evento não precisa esperar a resposta.
- **Desacoplamento espacial:** Os serviços não precisam conhecer diretamente uns aos outros.
- **Resiliência:** Se um serviço estiver indisponível, os eventos podem ser processados quando ele voltar.
- **Escalabilidade:** Múltiplos serviços podem reagir ao mesmo evento independentemente.

Uma observação importante é que a arquitetura orientada a eventos não é exclusiva de microservices. O sistema reagir a eventos é um conceito muito antigo e usado em diversos tipos de sistemas.

```php
<?php

// Evento carrega apenas informações essenciais
class PedidoConfirmadoEvent
{
    public function __construct(
        public string $pedidoId,
        public string $clienteId,
        public array $itens, // Apenas IDs e quantidades
        public Dinheiro $valor,
        public DateTime $dataConfirmacao
    ) {}
}

// Contexto de Pedidos age como Publisher
class PedidosService
{
    public function __construct(
        private PedidoRepository $repository,
        private EventBus $eventBus
    ) {}
    
    public function confirmarPedido(string $pedidoId): void
    {
        $pedido = $this->repository->buscar($pedidoId);
        
        // Todas as validações acontecem dentro do contexto
        if (!$pedido->podeSerConfirmado()) {
            throw new DomainException('Pedido não pode ser confirmado');
        }
        
        $pedido->confirmar();
        $this->repository->salvar($pedido);
        
        // Publica evento para outros contextos interessados
        $this->eventBus->publish(
            new PedidoConfirmadoEvent(
                $pedido->getId(),
                $pedido->getClienteId(),
                $pedido->getItensResumo(), // Não expõe modelo interno
                $pedido->getValorTotal(),
                new DateTime()
            )
        );
    }
}

// Contexto de Estoque age como Subscriber
class EstoqueService
{
    public function quandoPedidoConfirmado(PedidoConfirmadoEvent $evento): void
    {
        // Cada contexto reage de acordo com suas próprias regras
        foreach ($evento->itens as $item) {
            $this->reservarItem($item['produtoId'], $item['quantidade']);
        }
        
        // Pode publicar seus próprios eventos
        if ($this->verificarEstoqueBaixo()) {
            $this->eventBus->publish(new EstoqueBaixoEvent());
        }
    }
    
    private function reservarItem(string $produtoId, int $quantidade): void
    {
        // Lógica específica do contexto de estoque
        $produto = $this->repository->buscar($produtoId);
        $produto->reservar($quantidade);
        $this->repository->salvar($produto);
    }
}
```

### Vantagens da Abordagem Baseada em Contextos

**1. Deployments Independentes:** Cada contexto pode ser deployado sem afetar os outros, desde que os contratos de eventos sejam mantidos.

**2. Tecnologias Diferentes:** Diferentes contextos podem usar tecnologias mais adequadas às suas necessidades específicas.

**3. Escalabilidade Granular:** Contextos com alta demanda podem ser escalados independentemente.

**4. Desenvolvimento Paralelo:** Equipes podem trabalhar em contextos diferentes simultaneamente.

### Desafios e Considerações

**Consistência Eventual:** Com eventos assíncronos, o sistema opera sob consistência eventual. Isso requer cuidado no design das operações.

**Complexidade de Monitoramento:** Rastrear operações que atravessam múltiplos serviços requer ferramentas adequadas de observabilidade.

**Gestão de Falhas:** É necessário implementar padrões como Saga Pattern para operações que envolvem múltiplos contextos.

## Padrões de Relacionamento Entre Contextos

Na prática, Bounded Contexts raramente operam completamente isolados. Eles precisam colaborar para entregar funcionalidades completas ao usuário final. O DDD define padrões específicos para organizar essas relações, cada um apropriado para diferentes cenários e níveis de acoplamento aceitáveis.

Estes padrões são fundamentais porque determinam:
- **Como os contextos se comunicam**
- **Quem tem autoridade sobre quais dados**
- **Como mudanças em um contexto afetam outros**
- **Qual nível de acoplamento é aceitável**

### 1. Partnership (Parceria)

**Quando Usar:** Dois contextos têm dependência mútua tão forte que precisam evoluir juntos, com coordenação constante entre as equipes responsáveis.

**Características:**
- Ambos os contextos dependem um do outro.
- Mudanças em um afetam o outro.
- Requer coordenação próxima entre equipes.
- Geralmente usado quando há forte integração temporal (operações síncronas).

**Cenário Típico:** Contextos de Carrinho e Preços em um e-commerce, onde o cálculo de preços precisa ser feito em tempo real durante a construção do carrinho.

```php
<?php

// Interface compartilhada e evoluída em conjunto
interface CarrinhoPrecoIntegration
{
    // Ambos os contextos concordam com esta interface
    public function calcularTotalCarrinho(array $itens): Dinheiro;
    public function aplicarDesconto(string $codigoDesconto, Dinheiro $total): Dinheiro;
    public function calcularImpostos(Dinheiro $subtotal, string $estado): Dinheiro;
}

// Contexto de Carrinho depende do contexto de Preços
namespace Carrinho;

class CarrinhoService
{
    public function __construct(
        private CarrinhoPrecoIntegration $calculadoraPrecos
    ) {}
    
    public function adicionarItem(string $carrinhoId, string $produtoId): void
    {
        $carrinho = $this->repository->buscar($carrinhoId);
        $carrinho->adicionarItem($produtoId);
        
        // Recalcula preços imediatamente
        $novoTotal = $this->calculadoraPrecos->calcularTotalCarrinho(
            $carrinho->getItens()
        );
        $carrinho->atualizarTotal($novoTotal);
    }
}

// Contexto de Preços também depende do contexto de Carrinho
namespace Precos;

class PrecoService implements CarrinhoPrecoIntegration
{
    public function calcularTotalCarrinho(array $itens): Dinheiro
    {
        // Precisa conhecer a estrutura dos itens do carrinho
        $total = new Dinheiro(0);
        foreach ($itens as $item) {
            $precoUnitario = $this->obterPrecoAtual($item->produtoId);
            $subtotal = $precoUnitario->multiplicar($item->quantidade);
            $total = $total->somar($subtotal);
        }
        return $total;
    }
}
```

**Riscos:** Alto acoplamento entre contextos, dificuldade para mudanças independentes, necessidade de coordenação constante entre equipes.

### 2. Shared Kernel (Núcleo Compartilhado)

**Quando Usar:** Múltiplos contextos precisam compartilhar um conjunto de conceitos fundamentais e estão dispostos a coordenar mudanças neste núcleo compartilhado.

**Características:**
- Código explicitamente compartilhado entre contextos.
- Mudanças requerem acordo entre todas as equipes envolvidas.
- Geralmente contém Value Objects e conceitos fundamentais.
- Deve ser pequeno e estável.

**Cenário Típico:** Conceitos como `Dinheiro`, `Email`, `CPF` que são fundamentais para múltiplos contextos.

```php
<?php

// Núcleo compartilhado - evoluído por consenso
namespace NucleoCompartilhado;

class Dinheiro
{
    public function __construct(
        public readonly float $valor,
        public readonly string $moeda
    ) {
        if ($valor < 0) {
            throw new InvalidArgumentException('Valor não pode ser negativo');
        }
        
        if (empty($moeda)) {
            throw new InvalidArgumentException('Moeda é obrigatória');
        }
    }
    
    public function somar(Dinheiro $outro): Dinheiro
    {
        if ($this->moeda !== $outro->moeda) {
            throw new InvalidArgumentException('Moedas devem ser iguais');
        }
        return new Dinheiro($this->valor + $outro->valor, $this->moeda);
    }
    
    public function multiplicar(int $fator): Dinheiro
    {
        return new Dinheiro($this->valor * $fator, $this->moeda);
    }
    
    public function maiorQue(Dinheiro $outro): bool
    {
        return $this->valor > $outro->valor;
    }
}

class Email
{
    public function __construct(
        private readonly string $endereco
    ) {
        if (!$this->isValido($endereco)) {
            throw new InvalidArgumentException('Email inválido');
        }
    }
    
    private function isValido(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }
    
    public function getEndereco(): string
    {
        return $this->endereco;
    }
    
    public function getDominio(): string
    {
        return substr($this->endereco, strpos($this->endereco, '@') + 1);
    }
}

// Múltiplos contextos usam estas classes
namespace Vendas;
use NucleoCompartilhado\{Dinheiro, Email};

class Cliente
{
    public function __construct(
        private Email $email,
        private Dinheiro $limiteCredito
    ) {}
}

namespace Marketing;
use NucleoCompartilhado\{Email};

class CampanhaEmail
{
    public function enviarPara(Email $destinatario): void
    {
        // Usa a mesma implementação de Email
    }
}
```

**Riscos:** Pode crescer descontroladamente, criar acoplamento excessivo, requerer coordenação complexa para mudanças.

### 3. Customer-Supplier (Cliente-Fornecedor)

**Quando Usar:** Um contexto (Supplier) fornece serviços para outro (Customer), mas há uma relação de prioridade clara onde o Supplier define a interface.

**Características:**
- Relação unidirecional: Customer depende do Supplier.
- Supplier tem prioridade na definição de interfaces.
- Customer deve se adaptar às mudanças do Supplier.
- Comunicação pode ser síncrona ou assíncrona.

**Cenário Típico:** Contexto de Identidade fornecendo autenticação para outros contextos.

```php
<?php

// Contexto de Identidade (Supplier) - define as regras
namespace Identidade;

class Usuario
{
    public function __construct(
        private string $id,
        private string $email,
        private array $permissoes
    ) {}
    
    public function temPermissao(string $permissao): bool
    {
        return in_array($permissao, $this->permissoes);
    }
    
    public function getId(): string
    {
        return $this->id;
    }
}

class IdentidadeService
{
    public function validarToken(string $token): ?Usuario
    {
        // Implementação do fornecedor - ele define como funciona
        $dadosToken = $this->decodificarToken($token);
        
        if (!$dadosToken || $this->tokenExpirado($dadosToken)) {
            return null;
        }
        
        return new Usuario(
            $dadosToken['userId'],
            $dadosToken['email'],
            $dadosToken['permissions']
        );
    }
    
    public function verificarPermissao(string $token, string $permissao): bool
    {
        $usuario = $this->validarToken($token);
        return $usuario && $usuario->temPermissao($permissao);
    }
    
    private function decodificarToken(string $token): ?array
    {
        // Lógica interna do fornecedor
        return ['userId' => '123', 'email' => 'user@test.com', 'permissions' => ['read']];
    }
    
    private function tokenExpirado(array $dadosToken): bool
    {
        // Lógica interna do fornecedor
        return false;
    }
}

// Contexto de Pedidos (Customer) - se adapta ao fornecedor
namespace Pedidos;

use Identidade\{IdentidadeService, Usuario};

class PedidosService
{
    public function __construct(
        private IdentidadeService $identidade
    ) {}
    
    public function criarPedido(string $token, array $itens): Pedido
    {
        // Customer deve usar a interface definida pelo Supplier
        $usuario = $this->identidade->validarToken($token);
        if (!$usuario) {
            throw new UnauthorizedException('Token inválido');
        }
        
        // Verifica permissão usando interface do Supplier
        if (!$this->identidade->verificarPermissao($token, 'criar_pedido')) {
            throw new ForbiddenException('Sem permissão para criar pedidos');
        }
        
        return new Pedido($usuario->getId(), $itens);
    }
    
    public function buscarPedidosUsuario(string $token): array
    {
        $usuario = $this->identidade->validarToken($token);
        if (!$usuario) {
            return [];
        }
        
        return $this->repository->buscarPorUsuario($usuario->getId());
    }
}
```

**Vantagens:** Clara separação de responsabilidades, Supplier pode evoluir com prioridade de suas necessidades.
**Riscos:** Customer fica dependente das decisões do Supplier, pode haver conflito de prioridades.

### 4. Anti-Corruption Layer (Camada Anti-Corrupção)

**Quando Usar:** Seu contexto precisa integrar com um sistema externo (legado, de terceiros, ou mal projetado) mas você quer proteger seu modelo de domínio de conceitos inadequados.

**Características:**
- Isola seu contexto de modelos externos inadequados.
- Traduz entre modelos de domínio diferentes.
- Fornece interface limpa para o contexto interno.
- Absorve mudanças do sistema externo.

**Cenário Típico:** Integração com gateway de pagamento externo que tem API inadequada para seu domínio.

```php
<?php

// Sistema externo com interface inadequada
interface SistemaPagamentoExterno
{
    // API mal projetada do sistema externo
    public function processPayment(string $cardNum, float $amt): PaymentResult;
    public function refundTransaction(string $txnId): RefundResult;
}

class PaymentResult
{
    public function __construct(
        public bool $success,
        public string $transactionId,
        public float $amount,
        public string $errorCode = '' // Códigos crípticos como "E001", "E999"
    ) {}
}

// Anti-Corruption Layer - protege seu domínio
class AdaptadorPagamento
{
    public function __construct(
        private SistemaPagamentoExterno $sistemaExterno
    ) {}
    
    public function processarPagamento(PagamentoDominio $pagamento): ResultadoPagamento
    {
        // Traduz do seu modelo rico para o modelo pobre externo
        $resultadoExterno = $this->sistemaExterno->processPayment(
            $pagamento->getCartao()->getNumeroMascarado(),
            $pagamento->getValor()->getValor()
        );
        
        // Traduz do modelo externo para o seu modelo rico
        return $this->traduzirResultado($resultadoExterno, $pagamento);
    }
    
    private function traduzirResultado(PaymentResult $externo, PagamentoDominio $pagamento): ResultadoPagamento
    {
        $status = $this->traduzirStatus($externo);
        $motivoFalha = $this->traduzirErro($externo->errorCode);
        
        return new ResultadoPagamento(
            $pagamento->getId(),
            $status,
            $externo->transactionId,
            new Dinheiro($externo->amount, 'BRL'),
            $motivoFalha
        );
    }
    
    private function traduzirStatus(PaymentResult $externo): StatusPagamento
    {
        return $externo->success 
            ? StatusPagamento::APROVADO 
            : StatusPagamento::REJEITADO;
    }
    
    private function traduzirErro(string $codigoExterno): ?string
    {
        // Traduz códigos crípticos para linguagem do domínio
        return match($codigoExterno) {
            'E001' => 'Cartão inválido',
            'E002' => 'Saldo insuficiente',
            'E003' => 'Cartão vencido',
            'E999' => 'Erro interno do processador',
            default => $codigoExterno ? 'Erro desconhecido' : null
        };
    }
}

// Seu contexto usa interface limpa
namespace Pagamento;

class PagamentoService
{
    public function __construct(
        private AdaptadorPagamento $adaptador
    ) {}
    
    public function processarPagamento(PagamentoDominio $pagamento): ResultadoPagamento
    {
        // Usa interface limpa, não conhece sistema externo
        $resultado = $this->adaptador->processarPagamento($pagamento);
        
        if ($resultado->foiAprovado()) {
            $pagamento->marcarComoAprovado($resultado->getTransacaoId());
        } else {
            $pagamento->marcarComoRejeitado($resultado->getMotivoFalha());
        }
        
        return $resultado;
    }
}

// Modelos do seu domínio - ricos e expressivos
class PagamentoDominio
{
    public function __construct(
        private string $id,
        private CartaoCredito $cartao,
        private Dinheiro $valor,
        private StatusPagamento $status = StatusPagamento::PENDENTE
    ) {}
    
    public function marcarComoAprovado(string $transacaoId): void
    {
        if ($this->status !== StatusPagamento::PENDENTE) {
            throw new DomainException('Pagamento já foi processado');
        }
        $this->status = StatusPagamento::APROVADO;
    }
    
    public function marcarComoRejeitado(string $motivo): void
    {
        $this->status = StatusPagamento::REJEITADO;
        // Pode ter lógica adicional, como notificar cliente
    }
}
```

**Vantagens:** Protege seu domínio de sistemas mal projetados, facilita mudanças futuras, permite evoluir independentemente.
**Custos:** Camada adicional de complexidade, necessidade de manter traduções, pode impactar performance.

## Armadilhas Comuns

### 1. Contextos Muito Pequenos
```php
<?php

// Contexto pequeno demais
namespace ValidacaoEmail;

class ValidadorEmail
{
    public function validar(string $email): bool
    {
        return filter_var($email, FILTER_VALIDATE_EMAIL) !== false;
    }
}
```

### 2. Contextos Muito Grandes
```php
<?php

// Contexto grande demais - faz muita coisa
namespace ComercioEletronico;

class Sistema
{
    // Mistura catálogo, pedidos, pagamento, entrega...
    public function buscarProdutos(): array { }
    public function criarPedido(): Pedido { }
    public function processarPagamento(): void { }
    public function calcularFrete(): Dinheiro { }
    public function rastrearEntrega(): string { }
}
```

### 3. Dependências Circulares
```php
<?php

// Dependência circular entre contextos
namespace Pedidos;

class PedidoService
{
    public function __construct(
        private EstoqueService $estoque //
    ) {}
}

namespace Estoque;

class EstoqueService
{
    public function __construct(
        private PedidoService $pedidos //
    ) {}
}
```

## Melhores Práticas

### 1. Comece com Contextos Maiores
```php
<?php

// Comece com contexto maior e refine depois
namespace ECommerce;

class Sistema
{
    // Implemente tudo aqui primeiro
    // Depois extraia contextos menores conforme necessário
}
```

### 2. Use Eventos para Comunicação
```php
<?php

// Comunicação assíncrona via eventos
class EstoqueService
{
    public function quandoPedidoConfirmado(PedidoConfirmadoEvent $evento): void
    {
        // Reage ao evento sem acoplar com contexto de pedidos
    }
}
```

### 3. Mantenha dados Consistentes Dentro do Contexto
```php
<?php

// Consistência dentro do bounded context
namespace Pedidos;

class PedidoService
{
    public function confirmarPedido(string $pedidoId): void
    {
        $pedido = $this->repository->buscar($pedidoId);
        $pedido->confirmar();
        
        // Tudo dentro da mesma transação
        $this->repository->salvar($pedido);
        $this->eventBus->publish(new PedidoConfirmadoEvent($pedido));
    }
}
```

### 4. Use Anti-Corruption Layers para Sistemas Externos
```php
<?php

// ACL protege o contexto de mudanças externas
class AdaptadorSistemaLegado
{
    public function buscarCliente(string $id): Cliente
    {
        $dadosLegado = $this->sistemaLegado->getCustomer($id);
        
        // Traduz modelo legado para modelo do contexto
        return new Cliente(
            $dadosLegado->custId,
            $dadosLegado->custName,
            new Email($dadosLegado->emailAddr)
        );
    }
}
```

## Bounded Contexts na Prática

### Sinais de Contextos Bem Definidos
1. **Equipes podem trabalhar independentemente**
2. **MudanÑas ficam isoladas dentro do contexto**
3. **A linguagem ubíqua é clara e específica**
4. **Os modelos são coesos e têm responsabilidades claras**
5. **A comunicação entre contextos é explícita**

### Evolução dos Contextos
```php
<?php

// Contexto pode evoluir e ser refinado
namespace PedidosV1;

// Versão inicial mais simples
class Pedido
{
    public array $itens = [];
    public float $total = 0;
}

// Depois evolui para algo mais sofisticado
namespace PedidosV2;

class Pedido
{
    private array $itens = [];
    private StatusPedido $status;
    private PoliticaCancelamento $politicaCancelamento;
    
    public function calcularTotal(): Dinheiro
    {
        $total = new Dinheiro(0, 'BRL');
        foreach ($this->itens as $item) {
            $total = $total->somar($item->calcularSubtotal());
        }
        return $total;
    }
}
```

## Conclusão

Bounded Contexts são uma das ferramentas mais poderosas do DDD para lidar com a complexidade de sistemas grandes. Eles permitem:

- **Dividir sistemas complexos** em partes menores e manejáveis
- **Reduzir acoplamento** entre diferentes áreas do sistema  
- **Aumentar coesão** dentro de cada contexto
- **Facilitar evolução independente** de diferentes partes
- **Clarificar responsabilidades** e ownership das equipes
- **Definir fronteiras naturais** para microservices

O segredo está em encontrar o equilíbrio certo: contextos nem muito pequenos (que criam complexidade desnecessária) nem muito grandes (que anulam os benefícios da separação).

No próximo artigo, vamos explorar como implementar esses conceitos através dos **Value Objects e Entities**, os "building blocks" fundamentais do design tático do DDD.

## Referências

- [Domain-Driven Design: Tackling Complexity in the Heart of Software - Eric Evans](https://www.amazon.com/Domain-Driven-Design-Tackling-Complexity-Software/dp/0321125215)
- [Implementing Domain-Driven Design - Vaughn Vernon](https://www.amazon.com/Implementing-Domain-Driven-Design-Vaughn-Vernon/dp/0321834577)

+++start+++

## Anterior
[DDD: Ubiquitous Language - A linguagem comum do domínio (Parte 2)](2.ddd-ubiquitous-language-linguagem-comum-dominio)

## Próximo
[DDD: Value Objects e Entities - Pilares do modelo de domínio (Parte 4)](4.ddd-value-objects-entities-pilares-modelo-dominio)

+++end+++