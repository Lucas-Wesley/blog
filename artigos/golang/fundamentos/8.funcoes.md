---
titulo: "Golang: Fun√ß√µes e Modularidade"
slug: "golang-funcoes-modularidade"
status: "draft"
date: "2025-04-15"
tags: ["golang", "fun√ß√µes", "modularidade"]
category: "üíª Golang"
description: "Aprenda a criar e usar fun√ß√µes em Golang para melhorar a modularidade do seu c√≥digo. Descubra como passar par√¢metros, retornar valores e usar fun√ß√µes an√¥nimas." 
---

```go
package main
import "fmt"

func main() {
    // Fun√ß√£o sem par√¢metros e sem retorno
    funcSemParametrosSemRetorno()

    // Fun√ß√£o com par√¢metros
    resultado := funcComParametros(5, 10)
    fmt.Println("Resultado da fun√ß√£o com par√¢metros:", resultado)

    // Fun√ß√£o com parametros e retorno
    soma := funcComRetorno(5, 10)
    fmt.Println("Resultado da fun√ß√£o com retorno:", soma)

    // Fun√ß√£o an√¥nima
    funcAnonima := func(x, y int) int {
        return x + y
    }
    resultadoAnonimo := funcAnonima(5, 10)
    fmt.Println("Resultado da fun√ß√£o an√¥nima:", resultadoAnonimo)
    // Fun√ß√£o vari√°dica
    resultadoVariadico := funcVariadico(1, 2, 3, 4, 5)
    fmt.Println("Resultado da fun√ß√£o vari√°dica:", resultadoVariadico)
}

// Fun√ß√£o sem par√¢metros e sem retorno
func funcSemParametrosSemRetorno() {
    fmt.Println("Esta √© uma fun√ß√£o sem par√¢metros e sem retorno.")
}
// Fun√ß√£o com par√¢metros e sem retorno
func funcComParametros(a, b int) int {
    return a + b
}
// Fun√ß√£o com retorno
func funcComRetorno(a, b int) int {
    return a + b
}
// Fun√ß√£o an√¥nima
func funcAnonima(x, y int) int {
    return x + y
}
// Fun√ß√£o vari√°dica
func funcVariadico(nums ...int) int {
    soma := 0
    for _, num := range nums {
        soma += num
    }
    return soma
}
// Fun√ß√£o com m√∫ltiplos retornos
func funcComMultiplosRetornos(a, b int) (int, int) {
    return a + b, a - b
}
// Fun√ß√£o com retorno nomeado
func funcComRetornoNomeado(a, b int) (soma int, subtracao int) {
    soma = a + b
    subtracao = a - b
    return
}
```

## Variadicas


## Closures

√â uma fun√ß√£o que captura o ambiente em que foi criada, permitindo acessar vari√°veis externas mesmo ap√≥s o escopo original ter sido encerrado. Isso √© √∫til para criar fun√ß√µes que mant√™m estado entre chamadas.




```go	
package main
import "fmt"
func main() {
    // Exemplo de closure
    contador := criarContador()
    fmt.Println(contador()) // Sa√≠da: 1
    fmt.Println(contador()) // Sa√≠da: 2
    fmt.Println(contador()) // Sa√≠da: 3
}
func criarContador() func() int {
    contador := 0
    return func() int {
        contador++
        return contador
    }
}
```


Tem mais itens sobre fun√ß√µes como goroutines e defer, mas isso fica para outro dia. Acredito que esses itens seja o suficiente para eu continuar mesmo estudos.

