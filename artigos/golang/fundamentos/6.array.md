---
title: "Golang: Arrays e Slices (Parte - 6)"
slug: "golang-arrays-e-slices-parte-6"
status: "published"
date: "2025-04-15 00:30"
tags: ["golang", "arrays", "slices"]
category: "üíª Golang"
description: "Arrays e slices em Go."
---

Vamos estudar **arrays** e **slices** em Go e suas diferen√ßas. Esses conceitos s√£o fundamentais para manipula√ß√£o de dados em Go.

### Declarando um Array
Um array em Go √© uma estrutura de dados com tamanho fixo. Sim, fixo.
Veja o exemplo abaixo:

```go
// Declarando um array de inteiros
var numeros [5]int

// Atribuindo valores ao array
numeros[0] = 10
numeros[1] = 20
numeros[2] = 30
numeros[3] = 40
numeros[4] = 50

// Imprimindo o array
fmt.Println("Array:", numeros)
```

No c√≥digo acima:
- Declaramos um array chamado `numeros` com 5 posi√ß√µes.
- Atribu√≠mos valores a cada posi√ß√£o usando √≠ndices.
- Por fim, imprimimos o array completo.

Mas o que acontece se tentarmos adicionar mais elementos?

```go
// Tentando adicionar mais elementos
numeros[5] = 60 // Isso causar√° um erro de compila√ß√£o
```
Isso resultar√° em um erro, pois o array tem um tamanho fixo de 5.

### Declarando um Array com Valores Iniciais
Voc√™ tamb√©m pode declarar um array com valores iniciais:

```go
// Declarando e inicializando um array de strings
var frutas = [3]string{"ma√ß√£", "banana", "laranja"}
// Imprimindo o array
fmt.Println("Array:", frutas)
```
Aqui:
- Declaramos um array chamado `frutas` com 3 elementos iniciais.
- Imprimimos o array completo.
- O tamanho do array √© inferido automaticamente com base nos valores iniciais.
- Voc√™ pode omitir o tamanho do array, e o Go ir√° inferir automaticamente.

```go
// Declarando um array sem especificar o tamanho
var numeros = [...]int{10, 20, 30, 40, 50}
// Imprimindo o array
fmt.Println("Array:", numeros)
```

Neste caso, o Go calcula o tamanho do array com base nos valores fornecidos.

### Acessando Elementos do Array
Para acessar elementos de um array, voc√™ usa o √≠ndice. Lembre-se de que os √≠ndices come√ßam em 0:

```go
// Acessando elementos do array
fmt.Println("Primeiro elemento:", numeros[0]) // Sa√≠da: 10
fmt.Println("Segundo elemento:", numeros[1]) // Sa√≠da: 20
```
Aqui:
- Acessamos o primeiro e o segundo elementos do array `numeros` usando seus √≠ndices.
- Imprimimos os valores correspondentes.

### Percorrendo um Array
Para percorrer um array, voc√™ pode usar um loop `for`:

```go
// Percorrendo o array
for i := 0; i < len(numeros); i++ {
    fmt.Println("Elemento", i, ":", numeros[i])
}
```
Aqui:
- Usamos um loop `for` para percorrer o array `numeros`.
- A fun√ß√£o `len` retorna o tamanho do array.
- Imprimimos cada elemento do array com seu √≠ndice correspondente.


√â isso, bem simples. Nada demais, como tem que ser. Agora, vamos entender os **slices**.


### Trabalhando com Slices
Os slices s√£o mais flex√≠veis que os arrays, pois podem crescer ou diminuir dinamicamente. Veja como utiliz√°-los:

```go
// Declarando e inicializando um slice de strings
frutas := []string{"ma√ß√£", "banana", "laranja"}

// Adicionando um elemento ao slice
frutas = append(frutas, "uva")

// Imprimindo o slice
fmt.Println("Slice:", frutas)
```

Aqui:
- Criamos um slice chamado `frutas` com tr√™s elementos iniciais.
- Usamos a fun√ß√£o `append` para adicionar o elemento `"uva"`.
- Imprimimos o slice atualizado.

### Diferen√ßas entre Arrays e Slices
1. **Tamanho**:
   - Arrays t√™m tamanho fixo, definido na declara√ß√£o.
   - Slices t√™m tamanho din√¢mico e podem crescer conforme necess√°rio.

2. **Flexibilidade**:
   - Arrays s√£o √∫teis quando o tamanho √© conhecido e fixo.
   - Slices s√£o mais usados no dia a dia devido √† sua flexibilidade.


Simples! 