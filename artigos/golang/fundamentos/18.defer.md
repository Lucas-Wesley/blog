---
title: "Golang: Defer (Parte 18)"
date: "2025-06-20 14:00"
status: "published"
description: "Explore a declaração `defer` em Go: entenda seu funcionamento LIFO, avaliação de argumentos, casos de uso para limpeza de recursos, recuperação de panics e como interage com valores de retorno nomeados."
autor: "Lucas Wesley Moreira Tinta"
category: "Golang"
slug: "golang-defer"
tags: ["Golang", "Defer", "Recursos", "Panic", "Recover", "LIFO", "Programação Concorrente"]
---

## Golang: Defer (Parte 18)

A declaração `defer` em Go é uma funcionalidade poderosa e idiomática que agenda uma chamada de função para ser executada justo antes que a função circundante retorne. Este mecanismo garante que ações de limpeza ou outras operações necessárias sejam realizadas de forma confiável, independentemente de como a função é encerrada — seja por um retorno normal, uma declaração `return` explícita, ou até mesmo um `panic`.

### 1. Uso Básico e Ordem de Execução

A sintaxe para `defer` é simples: você simplesmente coloca a palavra-chave `defer` antes de uma chamada de função.

```go
package main

import "fmt"

func main() {
	defer fmt.Println("Isso será impresso por último.")
	fmt.Println("Isso será impresso primeiro.")
}
```

**Saída:**
```
Isso será impresso primeiro.
Isso será impresso por último.
```

Quando múltiplas declarações `defer` estão presentes dentro de uma única função, elas são executadas na ordem Last-In, First-Out (LIFO). Isso significa que a declaração `defer` encontrada mais recentemente será executada primeiro, e a declaração `defer` encontrada mais cedo será executada por último.

```go
package main

import "fmt"

func main() {
	defer fmt.Println("Terceiro (LIFO: 1º executado)")
	defer fmt.Println("Segundo (LIFO: 2º executado)")
	defer fmt.Println("Primeiro (LIFO: 3º executado)")

	fmt.Println("Corpo da função executando...")
}
```

**Saída:**
```
Corpo da função executando...
Primeiro (LIFO: 3º executado)
Segundo (LIFO: 2º executado)
Terceiro (LIFO: 1º executado)
```

### 2. Avaliação de Argumentos

Um aspecto crucial de `defer` que frequentemente surpreende os recém-chegados é como os argumentos para funções deferidas são tratados. Os argumentos para uma função deferida são avaliados *imediatamente* quando a declaração `defer` é encontrada, não quando a função deferida realmente é executada.

Considere o seguinte exemplo:

```go
package main

import "fmt"

func main() {
	i := 0
	defer fmt.Println("Valor deferido:", i) // i é avaliado aqui (0)
	i++
	fmt.Println("Valor atual:", i) // i agora é 1
}
```

**Saída:**
```
Valor atual: 1
Valor deferido: 0
```

Neste caso, `i` era `0` quando `defer fmt.Println("Valor deferido:", i)` foi processado. O valor `0` foi capturado e armazenado para a chamada `Println`, mesmo que `i` tenha sido incrementado para `1` antes da função deferida ser executada.

Se você precisa que a função deferida use o valor *final* de uma variável, você pode conseguir isso envolvendo a chamada deferida em uma closure ou passando um ponteiro para a variável.

**Usando uma Closure:**

```go
package main

import "fmt"

func main() {
	i := 0
	defer func() {
		fmt.Println("Valor deferido (closure):", i) // i é avaliado quando a closure é executada (1)
	}()
	i++
	fmt.Println("Valor atual:", i)
}
```

**Saída:**
```
Valor atual: 1
Valor deferido (closure): 1
```

**Usando um Ponteiro:**

```go
package main

import "fmt"

func main() {
	i := 0
	defer func(val *int) {
		fmt.Println("Valor deferido (ponteiro):", *val) // *val é avaliado quando a closure é executada (1)
	}(&i) // O endereço de i é capturado imediatamente
	i++
	fmt.Println("Valor atual:", i)
}
```

**Saída:**
```
Valor atual: 1
Valor deferido (ponteiro): 1
```

### 3. Casos de Uso Comuns

`defer` é incrivelmente útil para garantir o gerenciamento adequado de recursos e simplificar o tratamento de erros.

#### Limpeza de Recursos

Um dos usos mais comuns e importantes de `defer` é garantir que recursos como arquivos, conexões de rede ou conexões de banco de dados sejam devidamente fechados ou liberados. Ao deferir o método `Close()` logo após abrir um recurso, você garante que o recurso será limpo, independentemente de como a função é encerrada (por exemplo, retorno normal, erro ou panic).

```go
package main

import (
	"fmt"
	"os"
)

func readFile(filename string) ([]byte, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, fmt.Errorf("falha ao abrir arquivo: %w", err)
	}
	// Deferir o fechamento do arquivo. Isso será executado quando readFile retornar.
	defer f.Close()

	// Simular leitura do conteúdo do arquivo
	content := make([]byte, 0)
	// Em um cenário real, você leria de f
	fmt.Printf("Arquivo aberto com sucesso: %s\n", filename)
	content = append(content, []byte("Olá Go Defer!")...)

	return content, nil
}

func main() {
	data, err := readFile("example.txt")
	if err != nil {
		fmt.Println("Erro:", err)
		return
	}
	fmt.Println("Conteúdo do arquivo:", string(data))

	// Exemplo com um arquivo inexistente para mostrar que defer ainda funciona na abertura bem-sucedida
	_, err = readFile("nonexistent.txt")
	if err != nil {
		fmt.Println("Erro:", err)
	}
}
```

#### Desbloqueio de Mutexes

Em programação concorrente, `defer` é inestimável para garantir que os mutexes sejam desbloqueados após serem bloqueados, prevenindo deadlocks.

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

var (
	mu      sync.Mutex
	counter int
)

func incrementCounter() {
	mu.Lock()
	defer mu.Unlock() // Garante que o mutex seja desbloqueado quando a função sair

	counter++
	fmt.Println("Contador:", counter)
	time.Sleep(10 * time.Millisecond) // Simula algum trabalho
}

func main() {
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func() {
			defer wg.Done()
			incrementCounter()
		}()
	}
	wg.Wait()
	fmt.Println("Valor final do contador:", counter)
}
```

#### Medição de Tempo de Execução / Logging

`defer` pode ser usado para medir o tempo de execução de uma função ou para registrar sua entrada e saída.

```go
package main

import (
	"fmt"
	"time"
)

func measureTime(name string) func() {
	start := time.Now()
	return func() {
		fmt.Printf("%s levou %v\n", name, time.Since(start))
	}
}

func longRunningOperation() {
	defer measureTime("longRunningOperation")() // Chama measureTime imediatamente, defere sua função retornada

	fmt.Println("Iniciando operação longa...")
	time.Sleep(2 * time.Second)
	fmt.Println("Operação longa finalizada.")
}

func main() {
	longRunningOperation()
}
```

#### Recuperação de Panics

`defer` desempenha um papel crítico no mecanismo de `panic` e `recover` do Go. Quando um `panic` ocorre, as funções deferidas são executadas normalmente antes que o programa termine (ou antes que uma chamada `recover` lide com o panic). Isso permite que `defer` seja usado para limpeza mesmo diante de erros de tempo de execução e, mais importante, para `recover` de um `panic`.

A função embutida `recover()` só pode ser chamada efetivamente dentro de uma função deferida. Se um `panic` ocorrer, a função deferida contendo `recover()` será executada. `recover()` então interromperá a sequência de panicking e retornará o valor passado para `panic()`.

```go
package main

import "fmt"

func safeDivide(a, b int) (result int, err error) {
	defer func() {
		if r := recover(); r != nil {
			fmt.Printf("Recuperado de panic: %v\n", r)
			err = fmt.Errorf("erro de tempo de execução: %v", r) // Define o valor de retorno nomeado
		}
	}()

	if b == 0 {
		panic("divisão por zero")
	}
	result = a / b
	return result, nil
}

func main() {
	fmt.Println("--- Exemplos de Divisão Segura ---")

	res, err := safeDivide(10, 2)
	if err != nil {
		fmt.Println("Erro:", err)
	} else {
		fmt.Println("Resultado de 10/2:", res)
	}

	res, err = safeDivide(10, 0) // Isso causará um panic
	if err != nil {
		fmt.Println("Erro:", err)
	} else {
		fmt.Println("Resultado de 10/0:", res)
	}

	fmt.Println("O programa continua após a recuperação.")
}
```

### 4. `defer` e Valores de Retorno Nomeados

Funções deferidas, especialmente quando definidas como closures, têm a capacidade de acessar e modificar os valores de retorno nomeados da função circundante. Essa modificação acontece *depois* que a declaração `return` definiu os valores de retorno, mas *antes* que a função realmente retorne para seu chamador. Isso é particularmente útil para pós-processar valores de retorno ou lidar com erros de operações de limpeza deferidas.

```go
package main

import "fmt"

func calculateAndModify() (result int) {
	result = 5 // Atribuição inicial ao valor de retorno nomeado

	defer func() {
		// Esta função deferida é executada após 'result = 5' e antes da função retornar.
		// Ela pode acessar e modificar 'result'.
		result *= 2
		fmt.Println("Função deferida modificou o resultado para:", result)
	}()

	fmt.Println("Dentro de calculateAndModify, o resultado é:", result)
	return // Retorna o valor de 'result' após as funções deferidas serem executadas
}

func main() {
	finalResult := calculateAndModify()
	fmt.Println("Resultado final de main:", finalResult)
}
```

**Saída:**
```
Dentro de calculateAndModify, o resultado é: 5
Função deferida modificou o resultado para: 10
Resultado final de main: 10
```

### 5. Considerações Importantes e Armadilhas

*   **Tratamento de Erros em Chamadas Deferidas**: Uma armadilha comum é ignorar erros retornados por funções deferidas, especialmente métodos `Close()`. Por exemplo, `defer file.Close()` executará `Close()`, mas qualquer erro que ele retorne será silenciosamente descartado. Para aplicações críticas, você pode querer lidar com esses erros explicitamente, muitas vezes combinando-os com o retorno de erro da função principal usando `errors.Join` e valores de retorno nomeados.

    ```go
    package main

    import (
    	"errors"
    	"fmt"
    	"os"
    )

    func processFile(filename string) (err error) {
    	f, err := os.Open(filename)
    	if err != nil {
    		return fmt.Errorf("falha ao abrir arquivo: %w", err)
    	}
    	// Use uma closure para lidar com o erro de f.Close()
    	defer func() {
    		closeErr := f.Close()
    		if closeErr != nil {
    			// Se houve um erro original, junte-os. Caso contrário, closeErr é o erro principal.
    			err = errors.Join(err, fmt.Errorf("erro ao fechar arquivo: %w", closeErr))
    		}
    	}()

    	// Simula algum processamento de arquivo que pode retornar um erro
    	// Para demonstração, digamos que o processamento falha para "bad_data.txt"
    	if filename == "bad_data.txt" {
    		return errors.New("erro de processamento simulado")
    	}

    	fmt.Printf("Arquivo processado com sucesso: %s\n", filename)
    	return nil
    }

    func main() {
    	fmt.Println("--- Exemplos de Processamento de Arquivos ---")

    	err := processFile("example.txt")
    	if err != nil {
    		fmt.Println("Erro ao processar example.txt:", err)
    	}

    	err = processFile("bad_data.txt")
    	if err != nil {
    		fmt.Println("Erro ao processar bad_data.txt:", err)
    	}

    	err = processFile("nonexistent.txt") // Abertura falhará, defer não executará f.Close()
    	if err != nil {
    		fmt.Println("Erro ao processar nonexistent.txt:", err)
    	}
    }
    ```

*   **`defer` dentro de loops**: Colocar `defer` dentro de um loop apertado pode levar ao esgotamento de recursos porque as funções deferidas não são executadas até que a *função que as contém* retorne. Isso pode causar um acúmulo de recursos não liberados (por exemplo, handles de arquivo abertos, conexões de banco de dados) se o loop iterar muitas vezes.

    ```go
    package main

    import (
    	"fmt"
    	"os"
	"log"
    )

    func processManyFilesBad(filenames []string) {
    	for _, filename := range filenames {
    		f, err := os.Open(filename)
    		if err != nil {
    			fmt.Printf("Erro ao abrir %s: %v\n", filename, err)
    			continue
    		}
    		// RUIM: defer dentro de um loop. O arquivo só será fechado quando processManyFilesBad retornar.
    		defer f.Close()
    		fmt.Printf("Aberto %s\n", filename)
    		// Em um cenário real, processe o conteúdo do arquivo aqui
    	}
    	fmt.Println("Loop finalizado. Todos os arquivos tentarão fechar agora (LIFO).")
    }

    func processManyFilesGood(filenames []string) {
    	for _, filename := range filenames {
    		func(fName string) { // Use uma função anônima para criar um novo escopo
    			f, err := os.Open(fName)
    			if err != nil {
    				fmt.Printf("Erro ao abrir %s: %v\n", fName, err)
    				return // Retorna da função anônima, acionando o defer
    			}
    			defer f.Close() // Defer agora tem escopo limitado à função anônima, fechando imediatamente
    			fmt.Printf("Aberto e processado %s\n", fName)
    			// Processe o conteúdo do arquivo aqui
    		}(filename) // Passa o nome do arquivo para a função anônima
    	}
    	fmt.Println("Loop finalizado. Arquivos fechados imediatamente após o processamento.")
    }

    func main() {
        // Cria alguns arquivos dummy para demonstração
        for i := 0; i < 3; i++ {
            fileName := fmt.Sprintf("temp_file_%d.txt", i)
            err := os.WriteFile(fileName, []byte(fmt.Sprintf("Conteúdo de %s", fileName)), 0644)
            if err != nil {
                log.Fatalf("Falha ao criar arquivo dummy: %v", err)
            }
            defer os.Remove(fileName) // Limpa arquivos dummy
        }

    	files := []string{"temp_file_0.txt", "temp_file_1.txt", "temp_file_2.txt"}

    	fmt.Println("\n--- Exemplo Ruim (defer no loop) ---")
    	processManyFilesBad(files)

    	fmt.Println("\n--- Exemplo Bom (defer em função interna) ---")
    	processManyFilesGood(files)
    }
    ```

### Conclusão

A declaração `defer` é uma funcionalidade fundamental e poderosa em Go que promove código limpo, robusto e legível. Ao entender seu tempo de execução, regras de avaliação de argumentos e casos de uso comuns, você pode gerenciar recursos de forma eficaz, lidar com erros graciosamente e escrever aplicações Go mais confiáveis. Sua simplicidade e garantia de execução a tornam uma ferramenta indispensável para qualquer desenvolvedor Go.

---

+++start+++

## Anterior
[Golang: Manipulação de arquivos (Parte 17)](./artigos/golang/fundamentos/17.manipulacao-de-arquivos.md)

## Próximo
[Golang: Ponteiros (Parte 10)](./artigos/golang/fundamentos/10.ponteiros.md)

+++end+++
